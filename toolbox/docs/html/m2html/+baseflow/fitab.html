<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of fitab</title>
  <meta name="keywords" content="fitab">
  <meta name="description" content="FITAB fit event-scale recession equation -dq/dt = aQ^b">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../function_index.html">Home</a> &gt;  <a href="function_index.html">+baseflow</a> &gt; fitab.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../function_index.html"><img alt="<" border="0" src="../html_img/left.png">&nbsp;Master index</a></td>
<td align="right"><a href="function_index.html">Index for +baseflow&nbsp;<img alt=">" border="0" src="../html_img/right.png"></a></td></tr></table>-->

<h1>fitab
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../html_img/up.png"></a></h2>
<div class="box"><strong>FITAB fit event-scale recession equation -dq/dt = aQ^b</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../html_img/up.png"></a></h2>
<div class="box"><strong>function [Fit,ok] = fitab(q,dqdt,method,varargin) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../html_img/up.png"></a></h2>
<div class="fragment"><pre class="comment">FITAB fit event-scale recession equation -dq/dt = aQ^b

 Syntax

     [Fit,ok] = fitab(q,dqdt,method,varargin)

 Description

     [Fit,ok] = fitab(q,dqdt,method) fits event-scale recession equation
     -dq/dt = aQ^b to estimate parameters a and b using the specified
     fitting method. Valid methods are ordinary least squares (ols),
     non-linear least squares (nls), quantile regression (qtl), mean
     difference ('mean'), median difference ('median').

 Required inputs

     q        vector double of discharge data (L T^-1)
     dqdt     vector double of discharge rate of change (L T^-2)
     method   char indicating the fitting method

 Optional inputs

     weights  vector double of weights for the fitting algorithm
     mask     vector logical mask to exclude values from fitting
     order    scalar, exponent in -dq/dt = aQ^b
     refqtls  2x1 double, x/y quantiles used if 'method' == 'envelope'
     quantile scalar double, quantile used if 'method' == 'qtl' (quantile regression)
     Nboot    scalar double, bootstrap sample size for quantile regression
     plotfit  logical scalar indicating whether to make a plot or not
     fitopts  struct containing fitting options (not currently implemented)

 Notes
     weights are set zero anywhere mask is false

     Use method 'envelope' to pass a line through an arbitrary x,y pair
     (refpoints), specified in terms of the quantile of the x/y data
     distributions. this method is similar to 'mean' or 'median', but allows
     different ref points for the x/y values, for example the median of the
     x values (0.50 quantile) and some other quantile of the y values. The
     default (recommended) behavior is to keep the x-quantile = 0.5 and vary
     the y-quantile to move the line up and down as desired to define an
     &quot;envelope&quot;

  Matt Cooper, 04-Nov-2022, https://github.com/mgcooper
 
 See also: <a href="prepfits.html" class="code" title="function [x,y,logx,logy,w,ok] = prepfits(q,dqdt,varargin)">prepfits</a>, <a href="fitevents.html" class="code" title="function [Fits,Results] = fitevents(Events,varargin)">fitevents</a></pre></div>


<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../html_img/up.png"></a></h2>

This function calls:
<ul style="list-style-image:url(../html_img/matlabicon.gif)">

<li><a href="open.html" class="code" title="function open(varargin)">open</a>	OPEN Open package namespace function file in the MATLAB Editor.</li></ul>


This function is called by:
<ul style="list-style-image:url(../html_img/matlabicon.gif)">
</ul>
<!-- crossreference -->


<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../html_img/up.png"></a></h2>
<ul style="list-style-image:url(../html_img/matlabicon.gif)">

<li><a href="#_sub1" class="code">function [ab,ci,ok] = fitOLS(logx,logy,weights,alpha,inoctave)</a></li>
<li><a href="#_sub2" class="code">function [ab,ci,ok] = fitLIN(logx,logy,weights,alpha,order)</a></li>
<li><a href="#_sub3" class="code">function [ab,ci,ok] = fitMED(logx,logy,weights,order,inoctave)</a></li>
<li><a href="#_sub4" class="code">function [ab,ci,ok] = fitENV(logx,logy,weights,order,refqtls,inoctave)</a></li>
<li><a href="#_sub5" class="code">function [ab,ci,ok] = fitQTL(logx,logy,weights,alpha,order,qtl,Nboot,inoctave)</a></li>
<li><a href="#_sub6" class="code">function [ab,ci,ok] = fitMLE(logx,logy,weights,alpha,sigx,sigy,rxy)</a></li>
<li><a href="#_sub7" class="code">function [ab,ci,ok,fselect] = fitNLS(x,y,logx,logy,weights,alpha,inoctave)</a></li>
<li><a href="#_sub8" class="code">function [Fit,ok] = evalFit(ab,x,y,ci,ok)</a></li>
<li><a href="#_sub9" class="code">function [ab,ci,ok,fselect] = fitNLS_matlab(x,y,logx,logy,weights,alpha)</a></li>
<li><a href="#_sub10" class="code">function [ab,ci,ok,fselect] = fitNLS_octave(x,y,logx,logy,weights,alpha)</a></li>
<li><a href="#_sub11" class="code">function ci = nlparci_octave(beta, CovB, alpha)</a></li>
<li><a href="#_sub12" class="code">function [weights, order, mask, qtl, refqtls, Nboot, alpha, plotfit] =</a></li></ul>



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../html_img/up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [Fit,ok] = fitab(q,dqdt,method,varargin)</a>
0002    <span class="comment">%FITAB fit event-scale recession equation -dq/dt = aQ^b</span>
0003    <span class="comment">%</span>
0004    <span class="comment">% Syntax</span>
0005    <span class="comment">%</span>
0006    <span class="comment">%     [Fit,ok] = fitab(q,dqdt,method,varargin)</span>
0007    <span class="comment">%</span>
0008    <span class="comment">% Description</span>
0009    <span class="comment">%</span>
0010    <span class="comment">%     [Fit,ok] = fitab(q,dqdt,method) fits event-scale recession equation</span>
0011    <span class="comment">%     -dq/dt = aQ^b to estimate parameters a and b using the specified</span>
0012    <span class="comment">%     fitting method. Valid methods are ordinary least squares (ols),</span>
0013    <span class="comment">%     non-linear least squares (nls), quantile regression (qtl), mean</span>
0014    <span class="comment">%     difference ('mean'), median difference ('median').</span>
0015    <span class="comment">%</span>
0016    <span class="comment">% Required inputs</span>
0017    <span class="comment">%</span>
0018    <span class="comment">%     q        vector double of discharge data (L T^-1)</span>
0019    <span class="comment">%     dqdt     vector double of discharge rate of change (L T^-2)</span>
0020    <span class="comment">%     method   char indicating the fitting method</span>
0021    <span class="comment">%</span>
0022    <span class="comment">% Optional inputs</span>
0023    <span class="comment">%</span>
0024    <span class="comment">%     weights  vector double of weights for the fitting algorithm</span>
0025    <span class="comment">%     mask     vector logical mask to exclude values from fitting</span>
0026    <span class="comment">%     order    scalar, exponent in -dq/dt = aQ^b</span>
0027    <span class="comment">%     refqtls  2x1 double, x/y quantiles used if 'method' == 'envelope'</span>
0028    <span class="comment">%     quantile scalar double, quantile used if 'method' == 'qtl' (quantile regression)</span>
0029    <span class="comment">%     Nboot    scalar double, bootstrap sample size for quantile regression</span>
0030    <span class="comment">%     plotfit  logical scalar indicating whether to make a plot or not</span>
0031    <span class="comment">%     fitopts  struct containing fitting options (not currently implemented)</span>
0032    <span class="comment">%</span>
0033    <span class="comment">% Notes</span>
0034    <span class="comment">%     weights are set zero anywhere mask is false</span>
0035    <span class="comment">%</span>
0036    <span class="comment">%     Use method 'envelope' to pass a line through an arbitrary x,y pair</span>
0037    <span class="comment">%     (refpoints), specified in terms of the quantile of the x/y data</span>
0038    <span class="comment">%     distributions. this method is similar to 'mean' or 'median', but allows</span>
0039    <span class="comment">%     different ref points for the x/y values, for example the median of the</span>
0040    <span class="comment">%     x values (0.50 quantile) and some other quantile of the y values. The</span>
0041    <span class="comment">%     default (recommended) behavior is to keep the x-quantile = 0.5 and vary</span>
0042    <span class="comment">%     the y-quantile to move the line up and down as desired to define an</span>
0043    <span class="comment">%     &quot;envelope&quot;</span>
0044    <span class="comment">%</span>
0045    <span class="comment">%  Matt Cooper, 04-Nov-2022, https://github.com/mgcooper</span>
0046    <span class="comment">%</span>
0047    <span class="comment">% See also: prepfits, fitevents</span>
0048 
0049    <span class="comment">% if called with no input, open this file</span>
0050    <span class="keyword">if</span> nargin == 0; <a href="open.html" class="code" title="function open(varargin)">open</a>(mfilename(<span class="string">'fullpath'</span>)); <span class="keyword">return</span>; <span class="keyword">end</span>
0051 
0052    <span class="keyword">persistent</span> inoctave
0053    <span class="keyword">if</span> isempty(inoctave); inoctave = exist(&quot;OCTAVE_VERSION&quot;, &quot;builtin&quot;)&gt;0;
0054    <span class="keyword">end</span>
0055 
0056    <span class="comment">% PARSE INPUTS</span>
0057    [weights, order, mask, qtl, refqtls, Nboot, alpha, plotfit] = parseinputs( <span class="keyword">...</span>
0058       q, dqdt, method, mfilename, varargin{:});
0059 
0060    <span class="comment">% PREP FITS</span>
0061    [x, y, logx, logy, weights, ok] = baseflow.prepfits( <span class="keyword">...</span>
0062       q, dqdt, <span class="string">'weights'</span>, weights, <span class="string">'mask'</span>, mask);
0063 
0064    <span class="comment">% FAST EXIT</span>
0065    <span class="keyword">if</span> ok == false
0066       Fit = nan; <span class="keyword">return</span>;
0067    <span class="keyword">end</span>
0068 
0069    <span class="comment">% If method = 'ols' and 'order' = 1, use method 'mean' with a line of slope 1</span>
0070    <span class="keyword">if</span> strcmp(method,<span class="string">'ols'</span>) &amp;&amp; order == 1
0071       method = <span class="string">'mean'</span>;
0072    <span class="keyword">end</span>
0073 
0074    <span class="comment">% SWITCH YARD</span>
0075    fselect = method;
0076 
0077    <span class="keyword">switch</span> method
0078       <span class="keyword">case</span> <span class="string">'ols'</span>
0079          [ab,ci,ok] = <a href="#_sub1" class="code" title="subfunction [ab,ci,ok] = fitOLS(logx,logy,weights,alpha,inoctave)">fitOLS</a>(logx,logy,weights,alpha,inoctave);
0080       <span class="keyword">case</span> <span class="string">'qtl'</span>
0081          [ab,ci,ok] = <a href="#_sub5" class="code" title="subfunction [ab,ci,ok] = fitQTL(logx,logy,weights,alpha,order,qtl,Nboot,inoctave)">fitQTL</a>(logx,logy,weights,alpha,order,qtl,Nboot,inoctave);
0082       <span class="keyword">case</span> <span class="string">'mle'</span>
0083          error(<span class="string">'mle fitting not currently supported'</span>);
0084          <span class="comment">% [ab,ci,ok] = fitMLE(logx,logy,weights,alpha,sigx,sigy,rxy);</span>
0085       <span class="keyword">case</span> <span class="string">'nls'</span>
0086          [ab,ci,ok,fselect] = <a href="#_sub7" class="code" title="subfunction [ab,ci,ok,fselect] = fitNLS(x,y,logx,logy,weights,alpha,inoctave)">fitNLS</a>(x,y,logx,logy,weights,alpha,inoctave);
0087       <span class="keyword">case</span> <span class="string">'mean'</span>
0088          [ab,ci,ok] = <a href="#_sub2" class="code" title="subfunction [ab,ci,ok] = fitLIN(logx,logy,weights,alpha,order)">fitLIN</a>(logx,logy,weights,alpha,order);
0089       <span class="keyword">case</span> <span class="string">'median'</span>
0090          [ab,ci,ok] = <a href="#_sub3" class="code" title="subfunction [ab,ci,ok] = fitMED(logx,logy,weights,order,inoctave)">fitMED</a>(logx,logy,weights,order,inoctave);
0091       <span class="keyword">case</span> <span class="string">'envelope'</span>
0092          [ab,ci,ok] = <a href="#_sub4" class="code" title="subfunction [ab,ci,ok] = fitENV(logx,logy,weights,order,refqtls,inoctave)">fitENV</a>(logx,logy,weights,order,refqtls,inoctave);
0093    <span class="keyword">end</span>
0094 
0095    <span class="comment">% EVALUATE THE FIT</span>
0096    [Fit,ok] = <a href="#_sub8" class="code" title="subfunction [Fit,ok] = evalFit(ab,x,y,ci,ok)">evalFit</a>(ab,x,y,ci,ok);
0097 
0098    <span class="keyword">if</span> exist(<span class="string">'fselect'</span>,<span class="string">'var'</span>)
0099       Fit.fselect = fselect;
0100    <span class="keyword">end</span>
0101 
0102    <span class="keyword">if</span> plotfit == true
0103       Fit.h = baseflow.pointcloudplot(q,dqdt,<span class="string">'reflines'</span>,{<span class="string">'userfit'</span>}, <span class="keyword">...</span>
0104          <span class="string">'userab'</span>,ab,<span class="string">'mask'</span>,mask,<span class="string">'usertext'</span>,method);
0105    <span class="keyword">end</span>
0106 
0107    <span class="comment">% use this when stepping through nlinfit</span>
0108    debug = false;
0109    <span class="keyword">if</span> debug == true
0110       pos = get(0,<span class="string">'defaultfigureposition'</span>);
0111       figure(<span class="string">'Position'</span>,[pos(1) pos(2) 2*pos(3) pos(4)]);
0112       subplot(1,2,1);
0113       loglog(X,y,<span class="string">'-o'</span>); hold on; plot(X,yfit,<span class="string">':'</span>);
0114       xlabel(<span class="string">'log Q'</span>); ylabel(<span class="string">'log -dQ/dt'</span>);
0115       legend(<span class="string">'data'</span>,<span class="string">'fit'</span>);
0116    
0117       subplot(1,2,2);
0118       plot(X,y,<span class="string">'-o'</span>); hold on; plot(X,yfit,<span class="string">':'</span>);
0119       xlabel(<span class="string">'Q'</span>); ylabel(<span class="string">'-dQ/dt'</span>);
0120       legend(<span class="string">'data'</span>,<span class="string">'fit'</span>);
0121    <span class="keyword">end</span>
0122 <span class="keyword">end</span>
0123 
0124 <span class="comment">% FITTING METHODS</span>
0125 <a name="_sub1" href="#_subfunctions" class="code">function [ab,ci,ok] = fitOLS(logx,logy,weights,alpha,inoctave)</a>
0126    <span class="comment">% ordinary least squares linear regression in log-log</span>
0127 
0128    <span class="comment">% TODO: replace this with octave compatible fitting</span>
0129 
0130    <span class="comment">% Set up fittype and options.</span>
0131    <span class="keyword">if</span> inoctave
0132       error(<span class="string">'ordinary least squares not currently supported in octave, use nls'</span>)
0133    <span class="keyword">else</span>
0134       ft = fittype(<span class="string">'poly1'</span>);
0135       fopts = fitoptions( <span class="string">'Method'</span>, <span class="string">'LinearLeastSquares'</span>);
0136       fopts = setfield(fopts,<span class="string">'Weights'</span>, weights);
0137       [f,~] = fit( logx, logy, ft, fopts );
0138       ab = fliplr(coeffvalues(f));
0139    <span class="keyword">end</span>
0140 
0141    <span class="comment">% transform a to linear space and package a/b</span>
0142    ab = [exp(ab(1)); ab(2)];
0143 
0144    <span class="comment">% transpose ci to be consistent with stats functions</span>
0145    ci = rot90(confint(f,alpha));
0146    ci(1,:) = exp(ci(1,:));
0147 
0148    <span class="comment">% generic failure check</span>
0149    ok = all(isreal(ab));
0150 <span class="keyword">end</span>
0151 
0152 <a name="_sub2" href="#_subfunctions" class="code">function [ab,ci,ok] = fitLIN(logx,logy,weights,alpha,order)</a>
0153    <span class="comment">% linear model fit in log-log, equivalent to forcing a line of slope 1 through</span>
0154    <span class="comment">% the mean x-y, with option to control the slope using input parameter 'order'</span>
0155 
0156    <span class="comment">% % not sure if this was ever functional</span>
0157    <span class="comment">% % check fitopts</span>
0158    <span class="comment">% if isfield(fitopts,'order')</span>
0159    <span class="comment">%    if isnumeric(fitopts.order); order = fitopts.order; end</span>
0160    <span class="comment">% end</span>
0161 
0162    <span class="comment">% apply the mask / weights</span>
0163    logx = logx(weights&gt;0);
0164    logy = logy(weights&gt;0);
0165 
0166    <span class="comment">% impose model order if provided</span>
0167    <span class="keyword">if</span> ~isnan(order)
0168       logx = order.*logx;
0169    <span class="keyword">end</span>
0170 
0171    [~,~,ci] = ttest(-logx,-logy,<span class="string">'Alpha'</span>,1-alpha);
0172 
0173    <span class="comment">% note: mean(x-y) = mean(x)-mean(y)</span>
0174    ab = [exp(-(mean(logx)-mean(logy))); order];
0175 
0176    <span class="comment">% transpose ci to be consistent with stats functions</span>
0177    ci = [exp(ci(1)) exp(ci(2)); ab(2), ab(2)];
0178 
0179    <span class="comment">% generic failure check</span>
0180    ok = all(isreal(ab));
0181 <span class="keyword">end</span>
0182 
0183 <a name="_sub3" href="#_subfunctions" class="code">function [ab,ci,ok] = fitMED(logx,logy,weights,order,inoctave)</a>
0184    <span class="comment">% force a line of slope 'order' through the median x-y</span>
0185 
0186    <span class="comment">% % not sure why this was here, order is passed in with default 1, maybe i was</span>
0187    <span class="comment">% gonna do away wiht that or maybe i was testing here before implementing that</span>
0188    <span class="comment">% order = 1;</span>
0189    <span class="comment">% if isfield(fitopts,'order')</span>
0190    <span class="comment">%    order = fitopts.order;</span>
0191    <span class="comment">% end</span>
0192 
0193    <span class="comment">% apply the mask / weights</span>
0194    logx = logx(weights&gt;0);
0195    logy = logy(weights&gt;0);
0196 
0197    logx = order*logx;
0198 
0199    <span class="keyword">if</span> inoctave
0200       pval = nan; <span class="comment">% ranksum and kruskalwallis both supported, need to implement</span>
0201    <span class="keyword">else</span>
0202       pval = signrank(-logx,-logy); <span class="comment">% or ranksum or kruskalwallis</span>
0203    <span class="keyword">end</span>
0204 
0205    <span class="comment">% med(x-y)!=med(x)-med(y)</span>
0206    ab = [exp(-(median(logx)-median(logy))); order];
0207 
0208    <span class="comment">% non-parametric test, no ci</span>
0209    ci = [ab(1), ab(1); ab(2), ab(2)];
0210 
0211    <span class="comment">% could return to this later</span>
0212    <span class="comment">%bootfun = @(x,y)(median(y)-median(x));</span>
0213    <span class="comment">%bootci(100,bootfun(logx,logy))</span>
0214 
0215    <span class="comment">% generic failure check</span>
0216    ok = all(isreal(ab));
0217 <span class="keyword">end</span>
0218 
0219 <a name="_sub4" href="#_subfunctions" class="code">function [ab,ci,ok] = fitENV(logx,logy,weights,order,refqtls,inoctave)</a>
0220    <span class="comment">% force a line of slope 'order' through any two points 'refpoints' that</span>
0221    <span class="comment">% together define an 'envelope'. default x refpoint is median(x). To control</span>
0222    <span class="comment">% the vertical location of the line, set y refpoint higher or lower while</span>
0223    <span class="comment">% keeping x refpoint constant.</span>
0224 
0225    <span class="comment">% note: require that quantiles are passed in rather than precomputed refpoints</span>
0226    <span class="comment">% so this can use the log values or linear values</span>
0227 
0228    <span class="comment">% % removed fitopts for now</span>
0229    <span class="comment">%    % check fitopts</span>
0230    <span class="comment">%       if isfield(fitopts,'order')</span>
0231    <span class="comment">%          if isnumeric(fitopts.order); order = fitopts.order; end</span>
0232    <span class="comment">%       end</span>
0233    <span class="comment">%</span>
0234    <span class="comment">%       if isfield(fitopts,'quantile')</span>
0235    <span class="comment">%          quantile = fitopts.quantile;</span>
0236    <span class="comment">%       end</span>
0237 
0238    <span class="comment">% apply the mask / weights</span>
0239    logx = logx(weights&gt;0);
0240    logy = logy(weights&gt;0);
0241    logx = order.*logx;
0242 
0243    <span class="comment">% force the line through the provided quantile</span>
0244    <span class="keyword">if</span> inoctave
0245       xbar = quantile(logx,refqtls(1),1,8);
0246       ybar = quantile(logy,refqtls(2),1,8);
0247    <span class="keyword">else</span>
0248       xbar = quantile(logx,refqtls(1),<span class="string">'Method'</span>,<span class="string">'approximate'</span>);
0249       ybar = quantile(logy,refqtls(2),<span class="string">'Method'</span>,<span class="string">'approximate'</span>);
0250    <span class="keyword">end</span>
0251 
0252    <span class="comment">% note: mean(x-y) = mean(x)-mean(y)</span>
0253    ab = [ exp(-(xbar-ybar)); order];
0254 
0255    <span class="comment">% transpose ci to be consistent with stats functions</span>
0256    ci = [nan nan; nan, nan];
0257 
0258    <span class="comment">% generic failure check</span>
0259    ok = all(isreal(ab));
0260 <span class="keyword">end</span>
0261 
0262 <a name="_sub5" href="#_subfunctions" class="code">function [ab,ci,ok] = fitQTL(logx,logy,weights,alpha,order,qtl,Nboot,inoctave)</a>
0263 
0264    <span class="comment">% quantile regression</span>
0265    <span class="keyword">if</span> inoctave
0266       error(<span class="string">'quantile regression not currently supported in octave, use nls'</span>)
0267    <span class="keyword">end</span>
0268 
0269    <span class="comment">% % If fitopts is abandoned, need to figure out how to deal with extra</span>
0270    <span class="comment">% parameters for quantile regression.</span>
0271    <span class="comment">% if isfield(fitopts,'qtl')</span>
0272    <span class="comment">%    qtl = fitopts.pctl;</span>
0273    <span class="comment">%    order = fitopts.order; % 1=linear regression</span>
0274    <span class="comment">%    Nboot = fitopts.Nboot;</span>
0275    <span class="comment">%    % alpha = fitopts.alpha;</span>
0276    <span class="comment">% elseif isnan(qtl)</span>
0277    <span class="comment">%    qtl = 0.05;</span>
0278    <span class="comment">% end</span>
0279 
0280    <span class="keyword">if</span> isnan(qtl)
0281       qtl = 0.05;
0282    <span class="keyword">end</span>
0283 
0284    <span class="comment">% apply the mask / weights</span>
0285    logx = logx(weights&gt;0);
0286    logy = logy(weights&gt;0);
0287 
0288    <span class="comment">% fit a,b using quantile regression</span>
0289    [ab,s] = quantreg(logx,logy,qtl,order,Nboot,1-alpha);
0290 
0291    <span class="comment">% transform a to linear space and package a/b</span>
0292    ab = [exp(ab(1)); ab(2)];
0293 
0294    <span class="comment">% transpose ci to be consistent with stats functions</span>
0295    ci = transpose(s.ci_boot);   <span class="comment">% comes in the same order as confint</span>
0296    ci(1,:) = exp(ci(1,:));
0297 
0298    <span class="comment">% generic failure check</span>
0299    ok = all(isreal(ab));
0300 <span class="keyword">end</span>
0301 
0302 <a name="_sub6" href="#_subfunctions" class="code">function [ab,ci,ok] = fitMLE(logx,logy,weights,alpha,sigx,sigy,rxy)</a>
0303 
0304    <span class="comment">% Set default values for maximum likelihood estimation</span>
0305    <span class="keyword">if</span> nargin == 2
0306       sigx     =  std(logx);       <span class="comment">% error in x</span>
0307       sigy     =  std(logy);       <span class="comment">% error in y</span>
0308       rxy      =  0;               <span class="comment">% correlation b/w error in x and y</span>
0309       alpha    =  0.68;            <span class="comment">% confidence level</span>
0310    <span class="keyword">end</span>
0311 
0312    <span class="comment">% fit</span>
0313    [ab,s] = yorkfit(logx,logy,sigx,sigy,rxy,1-alpha);
0314 
0315    ab = [exp(ab(1)); ab(2)];
0316 
0317    <span class="comment">% transpose ci to be consistent with stats functions</span>
0318    ci = [exp(s.a_L), exp(s.a_H); s.b_L, s.b_H];
0319 
0320    <span class="comment">% generic failure check</span>
0321    ok = true;
0322    <span class="keyword">if</span> any(~isreal(ab))
0323       ok = false;
0324    <span class="keyword">end</span>
0325 <span class="keyword">end</span>
0326 
0327 <a name="_sub7" href="#_subfunctions" class="code">function [ab,ci,ok,fselect] = fitNLS(x,y,logx,logy,weights,alpha,inoctave)</a>
0328 
0329    <span class="keyword">if</span> inoctave
0330       [ab,ci,ok,fselect] = <a href="#_sub10" class="code" title="subfunction [ab,ci,ok,fselect] = fitNLS_octave(x,y,logx,logy,weights,alpha)">fitNLS_octave</a>(x,y,logx,logy,weights,alpha);
0331    <span class="keyword">else</span>
0332       <span class="keyword">try</span>
0333          [ab,ci,ok,fselect] = <a href="#_sub9" class="code" title="subfunction [ab,ci,ok,fselect] = fitNLS_matlab(x,y,logx,logy,weights,alpha)">fitNLS_matlab</a>(x,y,logx,logy,weights,alpha);
0334       <span class="keyword">catch</span>
0335          [ab,ci,ok,fselect] = <a href="#_sub10" class="code" title="subfunction [ab,ci,ok,fselect] = fitNLS_octave(x,y,logx,logy,weights,alpha)">fitNLS_octave</a>(x,y,logx,logy,weights,alpha);
0336       <span class="keyword">end</span>
0337    <span class="keyword">end</span>
0338 <span class="keyword">end</span>
0339 
0340 <a name="_sub8" href="#_subfunctions" class="code">function [Fit,ok] = evalFit(ab,x,y,ci,ok)</a>
0341 
0342    <span class="comment">% ok is from the fitting function, passed in here but not used</span>
0343    <span class="keyword">if</span> ok == false
0344       <span class="comment">% error?</span>
0345    <span class="keyword">end</span>
0346 
0347    Fit.ab = ab;
0348 
0349    <span class="comment">% all ci's should already be transformed to this form:</span>
0350    Fit.a = ab(1);
0351    Fit.b = ab(2);
0352    Fit.aL = ci(1,1);
0353    Fit.aH = ci(1,2);
0354    Fit.bL = ci(2,1);
0355    Fit.bH = ci(2,2);
0356 
0357    Fit.rsq = baseflow.deps.rsquare(y,ab(1).*x.^ab(2));
0358    Fit.pvalue = nan;
0359    Fit.N = numel(y);
0360    Fit.x = x;
0361    Fit.y = y;
0362 
0363    <span class="comment">% generic failure check</span>
0364    ok = all(isreal(ab));
0365 
0366    <span class="comment">%    % any log-log regressions need the ci's transormed like this:</span>
0367    <span class="comment">%    aL      = exp(ci(1,1)); % 95% CI</span>
0368    <span class="comment">%    aH      = exp(ci(1,2));</span>
0369    <span class="comment">%    bL      = ci(2,1);      % = betaL</span>
0370    <span class="comment">%    bH      = ci(2,2);      % = betaH</span>
0371 
0372    <span class="comment">%    % any nlinfit regressions should already be in teh right order:</span>
0373    <span class="comment">%    aL      = ci(1,1); % for confint: ci(1,1);</span>
0374    <span class="comment">%    aH      = ci(1,2); % for confint: ci(2,1);</span>
0375    <span class="comment">%    bL      = ci(2,1); % for confint: ci(1,2);</span>
0376    <span class="comment">%    bH      = ci(2,2); % for confint: ci(2,2);</span>
0377 
0378    <span class="comment">% this does not work if robust fitting is used</span>
0379    <span class="comment">%r2      = 1-sum(R.^2)/sum((y-mean(y)).^2); % for fit: gof.rsquare;</span>
0380    <span class="comment">%figure; loglog(x,y,'o'); hold on; loglog(x,ab(1).*x.^ab(2))</span>
0381 <span class="keyword">end</span>
0382 
0383 <a name="_sub9" href="#_subfunctions" class="code">function [ab,ci,ok,fselect] = fitNLS_matlab(x,y,logx,logy,weights,alpha)</a>
0384 
0385    <span class="comment">% initial estimates using log-log linear fit</span>
0386    ok = true;
0387    ab0 = [ones(size(x)) logx]\logy;
0388    ab0 = [exp(ab0(1)), ab0(2)];
0389 
0390    <span class="comment">% to use user-specified weights:</span>
0391    <span class="comment">%opts = statset('Display','off','RobustWgtFun',[]);</span>
0392    <span class="comment">%ab = nlinfit(q,dqdt,fnc,ab0,opts,'Weights',weights);</span>
0393 
0394    <span class="comment">% initialize r2</span>
0395    rsq0 = baseflow.deps.rsquare(y,ab0(1).*x.^ab0(2));
0396    rsq = rsq0;
0397 
0398    <span class="comment">% 'nlinfit' function options</span>
0399    fnc = @(ab,x)ab(1).*x.^ab(2);
0400 
0401    <span class="comment">% fnc = @(ab,x)ab(1).^(3-2.*ab(2)).*x.^ab(2);</span>
0402 
0403    <span class="comment">% opts1 = statset('Display','off','RobustWgtFun','bisquare');</span>
0404    opts1 = statset(<span class="string">'Display'</span>,<span class="string">'off'</span>,<span class="string">'RobustWgtFun'</span>,<span class="string">'bisquare'</span>);
0405    opts2 = statset(<span class="string">'Display'</span>,<span class="string">'off'</span>);
0406 
0407    <span class="comment">% 'fit' function options</span>
0408    ftype = fittype(@(a,b,x) (a.*x.^b));
0409 
0410    opts3 = fitoptions(<span class="string">'Method'</span>,<span class="string">'NonlinearLeastSquares'</span>,<span class="string">'Display'</span>,<span class="keyword">...</span>
0411       <span class="string">'off'</span>,<span class="string">'Robust'</span>,<span class="string">'Bisquare'</span>,<span class="string">'StartPoint'</span>,[ab0(1) ab0(2)]);
0412 
0413    opts4 = fitoptions(<span class="string">'Method'</span>,<span class="string">'NonlinearLeastSquares'</span>,          <span class="keyword">...</span>
0414       <span class="string">'Display'</span>,<span class="string">'off'</span>,<span class="string">'StartPoint'</span>,[ab0(1) ab0(2)]);
0415 
0416    <span class="comment">%  Summary of the method:</span>
0417 
0418    <span class="comment">%  start with linear=rsq0, set rsq=rsq0</span>
0419    <span class="comment">%  try nlinfit=rsq1, if rsq1&gt;rsq, set rsq=rsq1 and select nlinfit robust</span>
0420    <span class="comment">%  else, try fit=rsq3, if rsq3&gt;rsq, set rsq=rsq3 and select fit robust</span>
0421    <span class="comment">%  else, select 'none', rsq still equals rsq0</span>
0422    <span class="comment">%  if 'none', try non-robust nlinfit=rsq2, if rsq2&gt;rsq, set rsq=rsq2 and</span>
0423    <span class="comment">%  select nlinfit non-robust</span>
0424    <span class="comment">%  else</span>
0425 
0426    <span class="comment">% try robust nonlinear least squares fitting</span>
0427    ab1ok = true;
0428    <span class="keyword">try</span>
0429       [ab1,R1,~,C1] = nlinfit(x,y,fnc,ab0,opts1); <span class="comment">% R=resids,C=error variance</span>
0430       rsq1 = baseflow.deps.rsquare(y,ab1(1).*x.^ab1(2));
0431 
0432    <span class="keyword">catch</span> ME
0433 
0434       <span class="keyword">if</span> (strcmp(ME.identifier,<span class="string">'stats:nlinfit:NoUsableObservations'</span>))
0435 
0436          msg = <span class="string">'Fitting failed using nlinfit at ab1'</span>;
0437          causeException = MException(<span class="string">'BFRA:fitab:fitting'</span>,msg);
0438          ME = addCause(ME,causeException);
0439 
0440       <span class="keyword">end</span>
0441       ab1ok = false;
0442       <span class="comment">% rethrow(ME)</span>
0443    <span class="keyword">end</span>
0444 
0445    <span class="comment">% if nlinfit worked and it's 'better' than rsq (here, rsq0), select it</span>
0446    <span class="keyword">if</span> ab1ok &amp;&amp; rsq1 &gt; rsq &amp;&amp; rsq1 &gt; 0
0447 
0448       fselect = <span class="string">'nlinfit_robust'</span>;
0449       rsq = rsq1;
0450    <span class="keyword">else</span>
0451 
0452       <span class="comment">% try curve fitting functions</span>
0453       ab3ok = true;
0454       <span class="keyword">try</span>
0455          f3 = fit(x,y,ftype,opts3);
0456          ab3 = coeffvalues(f3);
0457          rsq3 = baseflow.deps.rsquare(y,ab3(1).*x.^ab3(2));
0458 
0459       <span class="keyword">catch</span> ME
0460 
0461          <span class="keyword">if</span> (strcmp(ME.identifier,<span class="string">'curvefit:fit:infComputed'</span>))
0462 
0463             msg = <span class="string">'Fitting failed using fit at ab3'</span>;
0464             causeException = MException(<span class="string">'BFRA:fitab:fitting'</span>,msg);
0465             ME = addCause(ME,causeException);
0466          <span class="keyword">end</span>
0467          ab3ok = false;
0468          <span class="comment">% rethrow(ME)</span>
0469       <span class="keyword">end</span>
0470 
0471       <span class="comment">% if fit worked, select it</span>
0472       <span class="keyword">if</span> ab3ok &amp;&amp; rsq3 &gt; rsq &amp;&amp; rsq3 &gt; 0
0473 
0474          fselect = <span class="string">'fit_robust'</span>;
0475          rsq = rsq3;
0476       <span class="keyword">else</span>
0477          fselect = <span class="string">'none'</span>;
0478 
0479       <span class="keyword">end</span>
0480    <span class="keyword">end</span>
0481 
0482    <span class="comment">% if neither nlinfit nor fit worked, try non-robust fitting</span>
0483    <span class="keyword">if</span> strcmp(fselect,<span class="string">'none'</span>)
0484 
0485       ab2ok = true;
0486       <span class="keyword">try</span>
0487          [ab2,R2,~,C2] = nlinfit(x,y,fnc,ab0,opts2);
0488          rsq2 = baseflow.deps.rsquare(y,ab2(1).*x.^ab2(2));
0489 
0490       <span class="keyword">catch</span> ME
0491 
0492          <span class="keyword">if</span> (strcmp(ME.identifier,<span class="string">'stats:nlinfit:NoUsableObservations'</span>))
0493 
0494             msg = <span class="string">'Fitting failed using nlinfit at ab2'</span>;
0495             causeException = MException(<span class="string">'BFRA:fitab:fitting'</span>,msg);
0496             ME = addCause(ME,causeException);
0497          <span class="keyword">end</span>
0498          ab2ok = false;
0499          <span class="comment">%rethrow(ME)</span>
0500       <span class="keyword">end</span>
0501 
0502       <span class="keyword">if</span> ab2ok &amp;&amp; rsq2 &gt; rsq &amp;&amp; rsq2 &gt; 0
0503 
0504          fselect = <span class="string">'nlinfit'</span>;
0505          rsq = rsq2;
0506 
0507       <span class="keyword">else</span> <span class="comment">% try curve fitting functions</span>
0508          ab4ok = true;
0509          <span class="keyword">try</span>
0510             f4 = fit(x,y,ftype,opts4); ab4 = coeffvalues(f4);
0511             rsq4 = baseflow.deps.rsquare(y,ab4(1).*x.^ab4(2));
0512 
0513          <span class="keyword">catch</span> ME
0514             <span class="keyword">if</span> (strcmp(ME.identifier,<span class="string">'curvefit:fit:infComputed'</span>))
0515 
0516                msg = <span class="string">'Fitting failed using fit at ab4'</span>;
0517                causeException = MException(<span class="string">'BFRA:fitab:fitting'</span>,msg);
0518                ME = addCause(ME,causeException);
0519             <span class="keyword">end</span>
0520             ab4ok = false;
0521             <span class="comment">%rethrow(ME)</span>
0522          <span class="keyword">end</span>
0523 
0524          <span class="comment">% we don't compare with rsq2 because we already know its &lt;rsq0</span>
0525          <span class="keyword">if</span> ab4ok &amp;&amp; rsq4 &gt; rsq &amp;&amp; rsq4 &gt; 0
0526             fselect = <span class="string">'fit'</span>;
0527             rsq = rsq4;
0528          <span class="keyword">else</span>
0529             fselect = <span class="string">'none'</span>;
0530          <span class="keyword">end</span>
0531       <span class="keyword">end</span>
0532    <span class="keyword">end</span>
0533 
0534    <span class="comment">% finally, if rsq is still low but linear rsq is good, choose lin</span>
0535    <span class="keyword">if</span> strcmp(fselect,<span class="string">'none'</span>) &amp;&amp; rsq &gt; 0
0536       fselect = <span class="string">'linear'</span>;
0537    <span class="keyword">elseif</span> rsq &lt; 0
0538       <span class="comment">% NOTE: nov 2022, i think in some cases we can get here and rsq &lt; 0 so I</span>
0539       <span class="comment">% added this option , previously there was no else, just end</span>
0540       fselect = <span class="string">'none'</span>;
0541    <span class="keyword">end</span>
0542 
0543    <span class="keyword">switch</span> fselect
0544 
0545       <span class="keyword">case</span> <span class="string">'none'</span>
0546          ok = false;   <span class="comment">% should never occur with option linear</span>
0547          ab = [nan,nan]; <span class="comment">% turns out can occur if q vs dqdt is decreasing</span>
0548          ci = [nan nan; nan nan];
0549 
0550       <span class="keyword">case</span> <span class="string">'nlinfit_robust'</span>
0551          ci = nlparci(ab1,R1,<span class="string">'covariance'</span>,C1,<span class="string">'alpha'</span>,alpha);
0552          ab = ab1;
0553 
0554       <span class="keyword">case</span> <span class="string">'nlinfit'</span>
0555          ci = nlparci(ab2,R2,<span class="string">'covariance'</span>,C2,<span class="string">'alpha'</span>,0.68);
0556          ab = ab2;
0557 
0558       <span class="keyword">case</span> <span class="string">'fit_robust'</span>
0559          ab = ab3;
0560          ci = transpose(confint(f3,alpha));
0561 
0562       <span class="keyword">case</span> <span class="string">'fit'</span>
0563          ab = ab4;
0564          ci = transpose(confint(f4,alpha));
0565 
0566       <span class="keyword">case</span> <span class="string">'linear'</span>
0567 
0568          [ab,ci] = regress(logy,[ones(size(y)) logx]);
0569          ci(1,:) = exp(ci(1,:));
0570          ab = [exp(ab(1)); ab(2)];
0571 
0572          <span class="comment">% might check metrics such as islineconvex(y), and if x&lt;xmin where</span>
0573          <span class="comment">% xmin is some very small flow value below which the data is corrupt</span>
0574    <span class="keyword">end</span>
0575 <span class="keyword">end</span>
0576 
0577 <a name="_sub10" href="#_subfunctions" class="code">function [ab,ci,ok,fselect] = fitNLS_octave(x,y,logx,logy,weights,alpha)</a>
0578 
0579    <span class="comment">% initial estimates using log-log linear fit</span>
0580    ok = true;
0581    ab0 = [ones(size(x)) logx]\logy;
0582    ab0 = [exp(ab0(1)), ab0(2)];
0583 
0584    <span class="comment">% initialize r2</span>
0585    rsq0 = baseflow.deps.rsquare(y,ab0(1).*x.^ab0(2));
0586    rsq = rsq0;
0587 
0588    <span class="comment">% 'nlinfit' function options</span>
0589    fnc = @(ab,x)ab(1).*x.^ab(2);
0590 
0591    opts2 = statset(<span class="string">'Display'</span>,<span class="string">'off'</span>);
0592 
0593    <span class="comment">%  Summary of the method:</span>
0594 
0595    <span class="comment">%  start with linear=rsq0, set rsq=rsq0</span>
0596    <span class="comment">%  try non-robust nlinfit=rsq2, if rsq2&gt;rsq, set rsq=rsq2 and</span>
0597    <span class="comment">%  select nlinfit non-robust</span>
0598    <span class="comment">%  else</span>
0599 
0600    <span class="comment">% try non-robust nonlinear least squares fitting</span>
0601    ab2ok = true;
0602    <span class="keyword">try</span>
0603       [ab2,R2,~,C2] = nlinfit(x,y,fnc,ab0,opts2);
0604       rsq2 = baseflow.deps.rsquare(y,ab2(1).*x.^ab2(2));
0605 
0606    <span class="keyword">catch</span> ME
0607 
0608       <span class="keyword">if</span> (strcmp(ME.identifier,<span class="string">'stats:nlinfit:NoUsableObservations'</span>))
0609 
0610          msg = <span class="string">'Fitting failed using nlinfit at ab2'</span>;
0611          causeException = MException(<span class="string">'BFRA:fitab:fitting'</span>,msg);
0612          ME = addCause(ME,causeException);
0613       <span class="keyword">end</span>
0614       ab2ok = false;
0615       <span class="comment">%rethrow(ME)</span>
0616    <span class="keyword">end</span>
0617 
0618    <span class="keyword">if</span> ab2ok &amp;&amp; rsq2 &gt; rsq &amp;&amp; rsq2 &gt; 0
0619 
0620       fselect = <span class="string">'nlinfit'</span>;
0621       rsq = rsq2;
0622    <span class="keyword">else</span>
0623       fselect = <span class="string">'none'</span>;
0624    <span class="keyword">end</span>
0625 
0626    <span class="comment">% finally, if rsq is still low but linear rsq is good, choose lin</span>
0627    <span class="keyword">if</span> strcmp(fselect,<span class="string">'none'</span>) &amp;&amp; rsq &gt; 0
0628       fselect = <span class="string">'linear'</span>;
0629    <span class="keyword">elseif</span> rsq &lt; 0
0630       fselect = <span class="string">'none'</span>;
0631    <span class="keyword">end</span>
0632 
0633    <span class="keyword">switch</span> fselect
0634 
0635       <span class="keyword">case</span> <span class="string">'none'</span>
0636          ok = false;
0637          ab = [nan,nan];
0638          ci = [nan nan; nan nan];
0639 
0640       <span class="keyword">case</span> <span class="string">'nlinfit'</span>
0641          ci = <a href="#_sub11" class="code" title="subfunction ci = nlparci_octave(beta, CovB, alpha)">nlparci_octave</a>(ab2, C2, 0.68);
0642          ab = ab2;
0643 
0644       <span class="keyword">case</span> <span class="string">'linear'</span>
0645 
0646          <span class="comment">%[B, BINT, R, RINT, STATS] = regress (Y, X, [ALPHA])</span>
0647 
0648          [ab,ci] = regress(logy,[ones(size(y)) logx]);
0649          ci(1,:) = exp(ci(1,:));
0650          ab = [exp(ab(1)); ab(2)];
0651    <span class="keyword">end</span>
0652 <span class="keyword">end</span>
0653 
0654 <a name="_sub11" href="#_subfunctions" class="code">function ci = nlparci_octave(beta, CovB, alpha)</a>
0655 
0656    <span class="comment">% INPUTS:</span>
0657    <span class="comment">%   beta: coefficients from nlinfit</span>
0658    <span class="comment">%   CovB: covariance matrix from nlinfit</span>
0659    <span class="comment">%   alpha: desired confidence level (e.g., 0.68 for 68%)</span>
0660    <span class="comment">%</span>
0661    <span class="comment">% OUTPUTS:</span>
0662    <span class="comment">%   ci_lower: lower bounds of the confidence intervals</span>
0663    <span class="comment">%   ci_upper: upper bounds of the confidence intervals</span>
0664 
0665    n = length(beta); <span class="comment">% Number of coefficients</span>
0666    dof = n - 1; <span class="comment">% Degrees of freedom</span>
0667    t_score = tinv(1 - (1 - alpha) / 2, dof); <span class="comment">% t-score for desired confidence level</span>
0668    se = sqrt(diag(CovB)); <span class="comment">% Standard errors of the coefficients</span>
0669    ci_lower = beta' - t_score * se; <span class="comment">% Lower bounds of the confidence intervals</span>
0670    ci_upper = beta' + t_score * se; <span class="comment">% Upper bounds of the confidence intervals</span>
0671    ci = [ci_lower, ci_upper];
0672 <span class="keyword">end</span>
0673 
0674 <span class="comment">%% INPUT PARSER</span>
0675 <a name="_sub12" href="#_subfunctions" class="code">function [weights, order, mask, qtl, refqtls, Nboot, alpha, plotfit] = </a><span class="keyword">...</span>
0676       parseinputs(q, dqdt, method, funcname, varargin)
0677 
0678    methodslist = {<span class="string">'nls'</span>,<span class="string">'ols'</span>,<span class="string">'mle'</span>,<span class="string">'qtl'</span>,<span class="string">'mean'</span>,<span class="string">'median'</span>,<span class="string">'envelope'</span>};
0679    validmethod = @(x) any(validatestring(x, methodslist));
0680 
0681    <span class="keyword">persistent</span> parser
0682    <span class="keyword">if</span> isempty(parser)
0683       parser = inputParser;
0684       parser.StructExpand = false;
0685       parser.addRequired( <span class="string">'q'</span>,                          @isnumeric   );
0686       parser.addRequired( <span class="string">'dqdt'</span>,                       @isnumeric   );
0687       parser.addRequired( <span class="string">'method'</span>,                     validmethod  );
0688       parser.addParameter(<span class="string">'weights'</span>,  1,                @isnumeric   );
0689       parser.addParameter(<span class="string">'order'</span>,    nan,              @isnumeric   );
0690       parser.addParameter(<span class="string">'mask'</span>,     1,                @islogical   );
0691       parser.addParameter(<span class="string">'quantile'</span>, 0.05,             @isnumeric   );
0692       parser.addParameter(<span class="string">'refqtls'</span>,  [0.50 0.50],      @isnumeric   );
0693       parser.addParameter(<span class="string">'Nboot'</span>,    100,              @isnumeric   );
0694       parser.addParameter(<span class="string">'alpha'</span>,    0.68,             @isnumeric   );
0695       parser.addParameter(<span class="string">'plotfit'</span>,  false,            @islogical   );
0696       parser.addParameter(<span class="string">'fitopts'</span>,  struct(),         @isstruct    );
0697    <span class="keyword">end</span>
0698    parser.FunctionName = funcname;
0699    parse(parser,q,dqdt,method,varargin{:});
0700 
0701    weights  = parser.Results.weights;
0702    order    = parser.Results.order;
0703    mask     = parser.Results.mask;
0704    qtl      = parser.Results.quantile;
0705    refqtls  = parser.Results.refqtls;
0706    Nboot    = parser.Results.Nboot;
0707    alpha    = parser.Results.alpha;
0708    plotfit  = parser.Results.plotfit;
0709    fitopts  = parser.Unmatched;
0710 
0711    <span class="keyword">if</span> isscalar(weights) &amp;&amp; weights == 1
0712       weights = ones(size(q));
0713    <span class="keyword">end</span>
0714 
0715    <span class="keyword">if</span> isscalar(mask) &amp;&amp; mask == 1
0716       mask = true(size(q));
0717    <span class="keyword">end</span>
0718 
0719    <span class="comment">% NOTE: fitopts is not implemented, but see baseflow.Fit, where it could be used</span>
0720    <span class="comment">% to simplify calling this function from wrapper functions. Using the</span>
0721    <span class="comment">% unmatched method, it can be used to pass in arbitrary fitopts accepted</span>
0722    <span class="comment">% by any function but requires that the user know what to pass in.</span>
0723 
0724    <span class="comment">% could require:</span>
0725    <span class="comment">% if method = 'qtl', fitopts.quantile, fitopts.Nboot</span>
0726    <span class="comment">% if method = 'mle', fitopts.sigx, fitopts.sigy, fitopts.rxy</span>
0727    <span class="comment">% for all methods, fitopts.order, fitopts.alpha, fitopts.</span>
0728 
0729 <span class="keyword">end</span></pre></div>
</body>
</html>