<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of wrapevents</title>
  <meta name="keywords" content="wrapevents">
  <meta name="description" content="WRAPEVENTS wrapper around bfra.getevents to get recession all recession events">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../function_index.html">Home</a> &gt;  <a href="function_index.html">+bfra</a> &gt; wrapevents.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../function_index.html"><img alt="<" border="0" src="../html_img/left.png">&nbsp;Master index</a></td>
<td align="right"><a href="function_index.html">Index for +bfra&nbsp;<img alt=">" border="0" src="../html_img/right.png"></a></td></tr></table>-->

<h1>wrapevents
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../html_img/up.png"></a></h2>
<div class="box"><strong>WRAPEVENTS wrapper around bfra.getevents to get recession all recession events</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../html_img/up.png"></a></h2>
<div class="box"><strong>function [Events] = wrapevents(T,Q,R,varargin) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../html_img/up.png"></a></h2>
<div class="fragment"><pre class="comment">WRAPEVENTS wrapper around bfra.getevents to get recession all recession events
for a mulit-year timeseries of T, Q, and R on an annual basis rather than for
all dates in the raw timeseries. NOTE: deprecated, needs updating with new
Events=bfra.getevents(...) syntax. Previously bfra.getevents, before the need
for this was eliminated by adding call to flattenevents to bfra.findevents and
renaming bfra.findevents to bfra.getevents. 

 
 Required inputs:
   T          =  nx1 array of dates
   Q          =  nxm array of daily flow in units m3/day, organized as calendar
                 years, meaning n/365 = # of years
   R          =  nxm array of daily rainfall in (mm/day?)
 
 Optional name-value inputs:
  qmin        =  minimum flow value, below which values are set nan
  nmin        =  minimum event length
  fmax        =  maximum # of missing values gap-filled
  rmax        =  maximum run of sequential constant values
  rmin        =  minimum rainfall required to censor flow
  rmconvex    =  remove convex derivatives
  rmnochange  =  remove consecutive constant derivates
  rmrain      =  remove rainfall
 
  opts        =  structure containing the fields listed above, in lieu of
                 entering them individually
 
 Note: flow comes in as m3/day/day
 
 See also findevents


 Matt Cooper, 04-Nov-2022, https://github.com/mgcooper</pre></div>


<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../html_img/up.png"></a></h2>

This function calls:
<ul style="list-style-image:url(../html_img/matlabicon.gif)">
</ul>


This function is called by:
<ul style="list-style-image:url(../html_img/matlabicon.gif)">
</ul>
<!-- crossreference -->


<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../html_img/up.png"></a></h2>
<ul style="list-style-image:url(../html_img/matlabicon.gif)">

<li><a href="#_sub1" class="code">function [T,Q,R,numyears,timestep] = prepinput(T,Q,R)</a></li></ul>



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../html_img/up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [Events] = wrapevents(T,Q,R,varargin)</a>
0002 <span class="comment">%WRAPEVENTS wrapper around bfra.getevents to get recession all recession events</span>
0003 <span class="comment">%for a mulit-year timeseries of T, Q, and R on an annual basis rather than for</span>
0004 <span class="comment">%all dates in the raw timeseries. NOTE: deprecated, needs updating with new</span>
0005 <span class="comment">%Events=bfra.getevents(...) syntax. Previously bfra.getevents, before the need</span>
0006 <span class="comment">%for this was eliminated by adding call to flattenevents to bfra.findevents and</span>
0007 <span class="comment">%renaming bfra.findevents to bfra.getevents.</span>
0008 <span class="comment">%</span>
0009 <span class="comment">%</span>
0010 <span class="comment">% Required inputs:</span>
0011 <span class="comment">%   T          =  nx1 array of dates</span>
0012 <span class="comment">%   Q          =  nxm array of daily flow in units m3/day, organized as calendar</span>
0013 <span class="comment">%                 years, meaning n/365 = # of years</span>
0014 <span class="comment">%   R          =  nxm array of daily rainfall in (mm/day?)</span>
0015 <span class="comment">%</span>
0016 <span class="comment">% Optional name-value inputs:</span>
0017 <span class="comment">%  qmin        =  minimum flow value, below which values are set nan</span>
0018 <span class="comment">%  nmin        =  minimum event length</span>
0019 <span class="comment">%  fmax        =  maximum # of missing values gap-filled</span>
0020 <span class="comment">%  rmax        =  maximum run of sequential constant values</span>
0021 <span class="comment">%  rmin        =  minimum rainfall required to censor flow</span>
0022 <span class="comment">%  rmconvex    =  remove convex derivatives</span>
0023 <span class="comment">%  rmnochange  =  remove consecutive constant derivates</span>
0024 <span class="comment">%  rmrain      =  remove rainfall</span>
0025 <span class="comment">%</span>
0026 <span class="comment">%  opts        =  structure containing the fields listed above, in lieu of</span>
0027 <span class="comment">%                 entering them individually</span>
0028 <span class="comment">%</span>
0029 <span class="comment">% Note: flow comes in as m3/day/day</span>
0030 <span class="comment">%</span>
0031 <span class="comment">% See also findevents</span>
0032 <span class="comment">%</span>
0033 <span class="comment">%</span>
0034 <span class="comment">% Matt Cooper, 04-Nov-2022, https://github.com/mgcooper</span>
0035 
0036 <span class="comment">% if called with no input, open this file</span>
0037 <span class="keyword">if</span> nargin == 0; open(mfilename(<span class="string">'fullpath'</span>)); <span class="keyword">return</span>; <span class="keyword">end</span>
0038 
0039 <span class="comment">% NOTE: this function is only needed to enforce year-by-year analysis.</span>
0040 <span class="comment">% findevents can be used on a timeseries of any length, but it will return</span>
0041 <span class="comment">% events in cell arrays which can then be flattened and reshaped to match a</span>
0042 <span class="comment">% regular calendar by bfra.flattenevents, rather than reshaping first here.</span>
0043 <span class="comment">% HOWEVER, this function also calls bfra.getdqdt to get a first-order estimate</span>
0044 <span class="comment">% of dqdt for quick plotting of a point cloud fit, for example. But, this should</span>
0045 <span class="comment">% almost surely be eliminated, and the output of this function should be passed</span>
0046 <span class="comment">% to fitdqdt independently of fitevents to get a quick dq/dt .</span>
0047 
0048 <span class="comment">%------------------------------------------------------------------------------</span>
0049 <span class="comment">%------------------------------------------------------------------------------</span>
0050 
0051 p              = inputParser;
0052 p.FunctionName = <span class="string">'bfra.wrapevents'</span>;
0053 p.StructExpand = true;
0054 
0055 addRequired(p, <span class="string">'T'</span>,                    @(x) isnumeric(x) | isdatetime(x)      );
0056 addRequired(p, <span class="string">'Q'</span>,                    @(x) isnumeric(x) &amp; numel(x)==numel(T) );
0057 addRequired(p, <span class="string">'R'</span>,                    @(x) isnumeric(x)                      );
0058 addParameter(p,<span class="string">'qmin'</span>,        0,       @(x) isnumeric(x) &amp; isscalar(x)        );
0059 addParameter(p,<span class="string">'nmin'</span>,        4,       @(x) isnumeric(x) &amp; isscalar(x)        );
0060 addParameter(p,<span class="string">'fmax'</span>,        1,       @(x) isnumeric(x) &amp; isscalar(x)        );
0061 addParameter(p,<span class="string">'rmax'</span>,        2,       @(x) isnumeric(x) &amp; isscalar(x)        );
0062 addParameter(p,<span class="string">'rmin'</span>,        0,       @(x) isnumeric(x) &amp; isscalar(x)        );
0063 addParameter(p,<span class="string">'cmax'</span>,        2,       @(x) isnumeric(x) &amp; isscalar(x)        );
0064 addParameter(p,<span class="string">'rmconvex'</span>,    false,   @(x) islogical(x) &amp; isscalar(x)        );
0065 addParameter(p,<span class="string">'rmnochange'</span>,  true,    @(x) islogical(x) &amp; isscalar(x)        );
0066 addParameter(p,<span class="string">'rmrain'</span>,      false,   @(x) islogical(x) &amp; isscalar(x)        );
0067 addParameter(p,<span class="string">'pickevents'</span>,  false,   @(x) islogical(x) &amp; isscalar(x)        );
0068 addParameter(p,<span class="string">'plotevents'</span>,  false,   @(x) islogical(x) &amp; isscalar(x)        );
0069 
0070 parse(p,T,Q,R,varargin{:});
0071 
0072 qmin        = p.Results.qmin;
0073 nmin        = p.Results.nmin;
0074 fmax        = p.Results.fmax;
0075 rmax        = p.Results.rmax;
0076 rmin        = p.Results.rmin;
0077 cmax        = p.Results.cmax;
0078 rmconvex    = p.Results.rmconvex;
0079 rmnochange  = p.Results.rmnochange;
0080 rmrain      = p.Results.rmrain;
0081 pickevents  = p.Results.pickevents;
0082 plotevents  = p.Results.plotevents;
0083 
0084 <span class="keyword">if</span> isempty(R); R = zeros(size(Q)); <span class="keyword">end</span>
0085 <span class="comment">%------------------------------------------------------------------------------</span>
0086 
0087 <span class="comment">% % for now, re-build opts to send to bfra.findevents</span>
0088 opts.qmin         = qmin;
0089 opts.nmin         = nmin;
0090 opts.fmax         = fmax;
0091 opts.rmax         = rmax;
0092 opts.rmin         = rmin;
0093 opts.cmax         = cmax;
0094 opts.rmconvex     = rmconvex;
0095 opts.rmnochange   = rmnochange;
0096 opts.rmrain       = rmrain;
0097 opts.plotevents   = plotevents;
0098 opts.pickevents   = pickevents;
0099 
0100 <span class="comment">% do some input checks</span>
0101 [T,Q,R,numyears]  = <a href="#_sub1" class="code" title="subfunction [T,Q,R,numyears,timestep] = prepinput(T,Q,R)">prepinput</a>(T,Q,R);
0102 
0103 <span class="comment">% save the T,Q arrays in 'events'</span>
0104 Events.inputT =  T;
0105 Events.inputQ =  Q;
0106 Events.inputR =  R;
0107 
0108 <span class="comment">% reshape the input lists to arrays (use of 'list' is a misnomer below)</span>
0109 numsteps = size(Q,1)/numyears;      <span class="comment">% number of timesteps per year</span>
0110 
0111 <span class="keyword">if</span> mod(numyears,1) == 0
0112    Qlist = reshape(Q,numsteps,numyears);    <span class="comment">% flow, each year</span>
0113    Rlist = reshape(R,numsteps,numyears);    <span class="comment">% rain, each year</span>
0114    Tlist = reshape(T,numsteps,numyears);    <span class="comment">% calendar, each year</span>
0115 <span class="keyword">else</span>
0116    <span class="comment">% assume data is already in a list</span>
0117    Qlist = Q;
0118    Rlist = R;
0119    Tlist = T;
0120 <span class="keyword">end</span>
0121 
0122 <span class="comment">% initialize output structure and output arrays</span>
0123 Qsave       =  nan(size(Qlist));
0124 Rsave       =  nan(size(Qlist));
0125 tsave       =  nan(size(Qlist));
0126 dQsave      =  nan(size(Qlist));
0127 qQsave      =  nan(size(Qlist));       <span class="comment">% approximated flow</span>
0128 tags        =  nan(size(Qlist));
0129 eventCount  =  0;                      <span class="comment">% initialize event counter</span>
0130 
0131 <span class="comment">%------------------------------------------------------------------------------</span>
0132 <span class="comment">% compute the recession constants</span>
0133 <span class="comment">%------------------------------------------------------------------------------</span>
0134 
0135 <span class="keyword">for</span> thisYear = 1:numyears      <span class="comment">% events for this year at this gage</span>
0136 
0137    <span class="keyword">if</span> all(isnan(Qlist(:,thisYear)))
0138       <span class="keyword">continue</span>;
0139    <span class="keyword">end</span>
0140 
0141    thisYearTime = Tlist(:,thisYear);
0142    thisYearFlow = Qlist(:,thisYear);
0143    thisYearRain = Rlist(:,thisYear);
0144 
0145    <span class="comment">% NEEDS TO BE UPDATED WITH NEW EVENTS = BFRA.GETEVENTS(...) SYNTAX</span>
0146    <span class="comment">% get events for this year</span>
0147    [T,Q,R,Info] = bfra.findevents(thisYearTime,thisYearFlow,thisYearRain,opts);
0148 
0149    <span class="comment">% for each event, compute q,dqdt with each derivative</span>
0150    numEvents = numel(Info.istart);
0151 
0152    <span class="keyword">for</span> thisEvent = 1:numEvents
0153 
0154       eventQ = Q{thisEvent};
0155       eventT = T{thisEvent};
0156       eventR = R{thisEvent};
0157 
0158       <span class="comment">% get approximated flow and dq/dt without any fitting of a/b</span>
0159       [qQ,dQ] = bfra.getdqdt(eventT,eventQ,eventR,<span class="string">'B1'</span>,<span class="string">'pickmethod'</span>,<span class="string">'none'</span>, <span class="keyword">...</span>
0160          <span class="string">'fitmethod'</span>,<span class="string">'none'</span>); 
0161       <span class="comment">% if fitmethod == &quot;none&quot;, only the dQdt is returned, for the case</span>
0162       <span class="comment">% where I don't wan't to fit events, so this function returns</span>
0163       <span class="comment">% everything needed to fit the distribution of qQ and dQ, i think</span>
0164 
0165       <span class="comment">% if no flow was returned, continue</span>
0166       <span class="keyword">if</span> all(isnan(eventQ)); <span class="keyword">continue</span>; <span class="keyword">else</span>
0167          eventCount = eventCount+1;
0168       <span class="keyword">end</span>
0169 
0170 
0171       <span class="comment">% get the start/end index on the year calendar</span>
0172       si = Info.istart(thisEvent);
0173       ei = Info.istop(thisEvent);
0174 
0175       <span class="comment">% collect all data for the point-cloud</span>
0176       Qsave(  si:ei,thisYear) = eventQ;
0177       Rsave(  si:ei,thisYear) = eventR;
0178       dQsave( si:ei,thisYear) = dQ;
0179       qQsave( si:ei,thisYear) = qQ;
0180       tsave(  si:ei,thisYear) = datenum(eventT);
0181       tags(   si:ei,thisYear) = eventCount; 
0182       <span class="comment">% eventCount tags events with index in K struct</span>
0183 
0184    <span class="keyword">end</span>
0185 
0186    <span class="comment">% pause to look at the fits</span>
0187    <span class="keyword">if</span> plotevents == true
0188       sprintf(<span class="string">'all events fitted for %d'</span>,thisYear); pause; close all
0189    <span class="keyword">end</span>
0190 <span class="keyword">end</span>
0191 
0192 [ndays,numyears] = size(Qsave);
0193 Events.eventT = reshape(tsave, ndays*numyears, 1);
0194 Events.eventQ = reshape(Qsave, ndays*numyears, 1);
0195 Events.eventR = reshape(Rsave, ndays*numyears, 1);
0196 Events.eventdqdt = reshape(dQsave,ndays*numyears, 1);
0197 Events.eventqq = reshape(qQsave,ndays*numyears, 1);
0198 Events.eventTags = reshape(tags,  ndays*numyears, 1);
0199 
0200 <span class="comment">% % should convert to timetable and add units</span>
0201 <span class="comment">% units = [&quot;m3 d-1&quot;,&quot;mm d-1&quot;,&quot;days&quot;,&quot;m3 d-1&quot;,&quot;mm d-1&quot;,&quot;m3 d-2&quot;,&quot;m3 d-1&quot;,&quot;-&quot;];</span>
0202 <span class="comment">% Events = struct2timetable(Events,'VariableUnits',units);</span>
0203 
0204 
0205 <span class="comment">%==========================================================================</span>
0206 
0207 <a name="_sub1" href="#_subfunctions" class="code">function [T,Q,R,numyears,timestep] = prepinput(T,Q,R)</a>
0208 <span class="comment">% PREPINPUT prepare input data - remove leap inds, determine timestep, determine</span>
0209 <span class="comment">% number of years.</span>
0210 
0211 <span class="comment">% NOTE: this is only needed if we want to enforce year-by-year analysis.</span>
0212 <span class="comment">% findevents can be used on a timeseries of any length, and could then be</span>
0213 <span class="comment">% flattened and reshaped to match some other calendar, rather than doing it</span>
0214 <span class="comment">% first, as in getevents</span>
0215 
0216 <span class="comment">% convert T to datetime</span>
0217 <span class="keyword">if</span> ~isdatetime(T); T =  datetime(T,<span class="string">'ConvertFrom'</span>,<span class="string">'datenum'</span>); <span class="keyword">end</span>
0218 
0219 <span class="comment">% check if the input data includes leap inds</span>
0220 hasleap = month(T)==2 &amp; day(T)==29;
0221 
0222 <span class="comment">% if the time is regular, we can get the timestep here</span>
0223 test = timetable(T,<span class="string">'RowTimes'</span>,T);
0224 <span class="keyword">if</span> isregular(test,<span class="string">'time'</span>)
0225    timestep = T(2)-T(1);
0226 <span class="keyword">else</span>
0227    <span class="comment">% if leap inds are already removed, the time won't be regular, so only</span>
0228    <span class="comment">% warn if time includes leap inds</span>
0229    <span class="keyword">if</span> any(hasleap)
0230       warning(<span class="string">'irregular calendar, results may be inconsistent'</span>)
0231    <span class="keyword">end</span>
0232 <span class="keyword">end</span>
0233 
0234 <span class="keyword">if</span> any(hasleap)
0235    warning(<span class="string">'removing leap inds'</span>);
0236    T(hasleap) = []; Q(hasleap) = []; R(hasleap) = [];
0237 <span class="keyword">end</span>
0238 
0239 <span class="comment">% this is correct</span>
0240 numyears = numel(T)/365;
0241 
0242 <span class="comment">% % both of these fail if water years are passed in</span>
0243 <span class="comment">% numyears = numel(unique(year(T)));</span>
0244 <span class="comment">%</span>
0245 <span class="comment">% firstyear   = year(T(1));</span>
0246 <span class="comment">% lastyear    = year(T(end));</span>
0247 <span class="comment">% numyears    = lastyear-firstyear+1;</span></pre></div>
</body>
</html>