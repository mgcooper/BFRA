<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of fitab</title>
  <meta name="keywords" content="fitab">
  <meta name="description" content="FITAB fit event-scale recession equation -dq/dt = aQ^b">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../function_index.html">Home</a> &gt;  <a href="function_index.html">+bfra</a> &gt; fitab.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../function_index.html"><img alt="<" border="0" src="../html_img/left.png">&nbsp;Master index</a></td>
<td align="right"><a href="function_index.html">Index for +bfra&nbsp;<img alt=">" border="0" src="../html_img/right.png"></a></td></tr></table>-->

<h1>fitab
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../html_img/up.png"></a></h2>
<div class="box"><strong>FITAB fit event-scale recession equation -dq/dt = aQ^b</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../html_img/up.png"></a></h2>
<div class="box"><strong>function [Fit,ok] = fitab(q,dqdt,method,varargin) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../html_img/up.png"></a></h2>
<div class="fragment"><pre class="comment">FITAB fit event-scale recession equation -dq/dt = aQ^b
 
 Syntax
 
     [Fit,ok] = fitab(q,dqdt,method,varargin)
 
 Description
 
     [Fit,ok] = fitab(q,dqdt,method) fits event-scale recession equation
     -dq/dt = aQ^b to estimate parameters a and b using the specified fitting
     method. Valid methods are ordinary least squares (ols), non-linear least
     squares (nls), quantile regression (qtl), mean difference ('mean'), median
     difference ('median').

 Required inputs
 
     q        vector double of discharge data (L T^-1)
     dqdt     vector double of discharge rate of change (L T^-2)
     method   char indicating the fitting method

 Optional inputs
 
     weights  vector double of weights for the fitting algorithm
     mask     vector logical mask to exclude values from fitting
     order    scalar, exponent in -dq/dt = aQ^b
     refqtls  2x1 double, x/y quantiles used if 'method' == 'envelope'
     quantile scalar double, quantile used if 'method' == 'qtl' (quantile regression)
     Nboot    scalar double, bootstrap sample size for quantile regression
     plotfit  logical scalar indicating whether to make a plot or not
     fitopts  struct containing fitting options (not currently implemented)

 See also <a href="prepfits.html" class="code" title="function [x,y,logx,logy,weights,success] = prepfits(q,dqdt,varargin)">prepfits</a>

 Matt Cooper, 04-Nov-2022, https://github.com/mgcooper</pre></div>


<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../html_img/up.png"></a></h2>

This function calls:
<ul style="list-style-image:url(../html_img/matlabicon.gif)">
</ul>


This function is called by:
<ul style="list-style-image:url(../html_img/matlabicon.gif)">

<li><a href="fitets.html" class="code" title="function [q,dqdt,dt,tq,rq,dq] = fitets(T,Q,R,varargin)">fitets</a>	FITETS fit recession event using the exponential timestep method</li></ul>
<!-- crossreference -->


<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../html_img/up.png"></a></h2>
<ul style="list-style-image:url(../html_img/matlabicon.gif)">

<li><a href="#_sub1" class="code">function [ab,ci,ok] = fitOLS(logx,logy,weights,alpha)</a></li>
<li><a href="#_sub2" class="code">function [ab,ci,ok] = fitLIN(logx,logy,weights,alpha,order,fitopts)</a></li>
<li><a href="#_sub3" class="code">function [ab,ci,ok] = fitMED(logx,logy,weights,order,fitopts)</a></li>
<li><a href="#_sub4" class="code">function [ab,ci,ok] = fitENV(logx,logy,weights,order,refqtls)</a></li>
<li><a href="#_sub5" class="code">function [ab,ci,ok] = fitQTL(logx,logy,weights,alpha,order,quantile,Nboot,fitopts)</a></li>
<li><a href="#_sub6" class="code">function [ab,ci,ok,fselect] = fitNLS(x,y,logx,logy,weights,alpha,fitopts)</a></li>
<li><a href="#_sub7" class="code">function [Fit,ok] = evalFit(ab,x,y,ci,ok)</a></li></ul>



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../html_img/up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [Fit,ok] = fitab(q,dqdt,method,varargin)</a>
0002 <span class="comment">%FITAB fit event-scale recession equation -dq/dt = aQ^b</span>
0003 <span class="comment">%</span>
0004 <span class="comment">% Syntax</span>
0005 <span class="comment">%</span>
0006 <span class="comment">%     [Fit,ok] = fitab(q,dqdt,method,varargin)</span>
0007 <span class="comment">%</span>
0008 <span class="comment">% Description</span>
0009 <span class="comment">%</span>
0010 <span class="comment">%     [Fit,ok] = fitab(q,dqdt,method) fits event-scale recession equation</span>
0011 <span class="comment">%     -dq/dt = aQ^b to estimate parameters a and b using the specified fitting</span>
0012 <span class="comment">%     method. Valid methods are ordinary least squares (ols), non-linear least</span>
0013 <span class="comment">%     squares (nls), quantile regression (qtl), mean difference ('mean'), median</span>
0014 <span class="comment">%     difference ('median').</span>
0015 <span class="comment">%</span>
0016 <span class="comment">% Required inputs</span>
0017 <span class="comment">%</span>
0018 <span class="comment">%     q        vector double of discharge data (L T^-1)</span>
0019 <span class="comment">%     dqdt     vector double of discharge rate of change (L T^-2)</span>
0020 <span class="comment">%     method   char indicating the fitting method</span>
0021 <span class="comment">%</span>
0022 <span class="comment">% Optional inputs</span>
0023 <span class="comment">%</span>
0024 <span class="comment">%     weights  vector double of weights for the fitting algorithm</span>
0025 <span class="comment">%     mask     vector logical mask to exclude values from fitting</span>
0026 <span class="comment">%     order    scalar, exponent in -dq/dt = aQ^b</span>
0027 <span class="comment">%     refqtls  2x1 double, x/y quantiles used if 'method' == 'envelope'</span>
0028 <span class="comment">%     quantile scalar double, quantile used if 'method' == 'qtl' (quantile regression)</span>
0029 <span class="comment">%     Nboot    scalar double, bootstrap sample size for quantile regression</span>
0030 <span class="comment">%     plotfit  logical scalar indicating whether to make a plot or not</span>
0031 <span class="comment">%     fitopts  struct containing fitting options (not currently implemented)</span>
0032 <span class="comment">%</span>
0033 <span class="comment">% See also prepfits</span>
0034 <span class="comment">%</span>
0035 <span class="comment">% Matt Cooper, 04-Nov-2022, https://github.com/mgcooper</span>
0036 
0037 <span class="comment">% if called with no input, open this file</span>
0038 <span class="keyword">if</span> nargin == 0; open(mfilename(<span class="string">'fullpath'</span>)); <span class="keyword">return</span>; <span class="keyword">end</span>
0039 
0040 <span class="comment">%-------------------------------------------------------------------------------</span>
0041 methodslist = {<span class="string">'nls'</span>,<span class="string">'ols'</span>,<span class="string">'mle'</span>,<span class="string">'qtl'</span>,<span class="string">'mean'</span>,<span class="string">'median'</span>,<span class="string">'envelope'</span>};
0042 validmethod = @(x)any(validatestring(x,methodslist));
0043 
0044 p              = inputParser;
0045 p.FunctionName = <span class="string">'bfra.fitab'</span>;
0046 p.StructExpand = false;
0047 <span class="comment">% p.PartialMatching = true;</span>
0048 
0049 addRequired(p, <span class="string">'q'</span>,                          @(x)isnumeric(x)     );
0050 addRequired(p, <span class="string">'dqdt'</span>,                       @(x)isnumeric(x)     );
0051 addRequired(p, <span class="string">'method'</span>,                     validmethod          );
0052 addParameter(p,<span class="string">'weights'</span>,  ones(size(q)),    @(x)isnumeric(x)     );
0053 addParameter(p,<span class="string">'order'</span>,    nan,              @(x)isnumeric(x)     );
0054 addParameter(p,<span class="string">'mask'</span>,     true(size(q)),    @(x)islogical(x)     );
0055 addParameter(p,<span class="string">'quantile'</span>, 0.05,             @(x)isnumeric(x)     );
0056 addParameter(p,<span class="string">'refqtls'</span>,  [0.50 0.50],      @(x)isnumeric(x)     );
0057 addParameter(p,<span class="string">'Nboot'</span>,    100,              @(x)isnumeric(x)     );
0058 addParameter(p,<span class="string">'alpha'</span>,    0.68,             @(x)isnumeric(x)     );
0059 addParameter(p,<span class="string">'plotfit'</span>,  false,            @(x)islogical(x)     );
0060 addParameter(p,<span class="string">'fitopts'</span>,  struct(),         @(x)isstruct(x)      );
0061 
0062 parse(p,q,dqdt,method,varargin{:});
0063 
0064 weights  = p.Results.weights;
0065 order    = p.Results.order;
0066 mask     = p.Results.mask;
0067 qtl      = p.Results.quantile;
0068 refqtls  = p.Results.refqtls;
0069 Nboot    = p.Results.Nboot;
0070 alpha    = p.Results.alpha;
0071 plotfit  = p.Results.plotfit;
0072 fitopts  = p.Unmatched;
0073 
0074 <span class="comment">% NOTE: fitopts is not implemented, but see bfra.Fit, where it could be used</span>
0075 <span class="comment">% to simplify calling this function from wrapper functions. Using the</span>
0076 <span class="comment">% unmatched method, it can be used to pass in arbitrary fitopts accepted</span>
0077 <span class="comment">% by any function but requires that the user know what to pass in.</span>
0078 
0079 <span class="comment">% could require:</span>
0080 <span class="comment">% if method = 'qtl', fitopts.quantile, fitopts.Nboot</span>
0081 <span class="comment">% if method = 'mle', fitopts.sigx, fitopts.sigy, fitopts.rxy</span>
0082 <span class="comment">% for all methods, fitopts.order, fitopts.alpha, fitopts.</span>
0083 
0084 <span class="comment">%-------------------------------------------------------------------------------</span>
0085 
0086 [x,y,logx,logy,weights,ok] = bfra.prepfits(q,dqdt,<span class="string">'weights'</span>,weights,<span class="string">'mask'</span>,mask);
0087 
0088 <span class="comment">% weights will equal zero anywhere mask is false</span>
0089 
0090 <span class="keyword">if</span> ok == false
0091    Fit = nan; <span class="keyword">return</span>;
0092 <span class="keyword">end</span>
0093 
0094 <span class="comment">% method 'envelope' allows for passing a line through an arbitrary x,y</span>
0095 <span class="comment">% pair (refpoints), specified in terms of the quantile of the x/y data</span>
0096 <span class="comment">% distributions. this method is similar to 'mean' or 'median', but allows</span>
0097 <span class="comment">% different ref points for the x/y values, for example the median of the x</span>
0098 <span class="comment">% values (0.50 quantile) and some other quantile of the y values. The</span>
0099 <span class="comment">% default (recommended) behavior is to keep the x-quantile = 0.5 and vary the</span>
0100 <span class="comment">% y-quantile to move the line up and down as desired to define an &quot;envelope&quot;</span>
0101 
0102 <span class="comment">% if method = 'ols' and 'order' = 1, assume they want a line of slope 1</span>
0103 <span class="keyword">if</span> strcmp(method,<span class="string">'ols'</span>) &amp;&amp; order == 1
0104    method = <span class="string">'mean'</span>;
0105 <span class="keyword">end</span>
0106 
0107 <span class="keyword">switch</span> method
0108    
0109    <span class="keyword">case</span> <span class="string">'ols'</span>
0110       [ab,ci,ok] = <a href="#_sub1" class="code" title="subfunction [ab,ci,ok] = fitOLS(logx,logy,weights,alpha)">fitOLS</a>(logx,logy,weights,alpha);
0111    <span class="keyword">case</span> <span class="string">'qtl'</span>
0112       [ab,ci,ok] = <a href="#_sub5" class="code" title="subfunction [ab,ci,ok] = fitQTL(logx,logy,weights,alpha,order,quantile,Nboot,fitopts)">fitQTL</a>(logx,logy,weights,alpha,order,qtl,Nboot,fitopts);
0113    <span class="keyword">case</span> <span class="string">'mle'</span>
0114       error(<span class="string">'mle fitting not currently supported'</span>);
0115       <span class="comment">% [ab,ci,ok] = fitMLE(logx,logy,weights,alpha,sigx,sigy,rxy);</span>
0116    <span class="keyword">case</span> <span class="string">'nls'</span>
0117       [ab,ci,ok,s]= <a href="#_sub6" class="code" title="subfunction [ab,ci,ok,fselect] = fitNLS(x,y,logx,logy,weights,alpha,fitopts)">fitNLS</a>(x,y,logx,logy,weights,alpha,fitopts);
0118    <span class="keyword">case</span> <span class="string">'mean'</span>
0119       [ab,ci,ok] = <a href="#_sub2" class="code" title="subfunction [ab,ci,ok] = fitLIN(logx,logy,weights,alpha,order,fitopts)">fitLIN</a>(logx,logy,weights,alpha,order,fitopts);
0120    <span class="keyword">case</span> <span class="string">'median'</span>
0121       [ab,ci,ok] = <a href="#_sub3" class="code" title="subfunction [ab,ci,ok] = fitMED(logx,logy,weights,order,fitopts)">fitMED</a>(logx,logy,weights,order,fitopts);
0122    <span class="keyword">case</span> <span class="string">'envelope'</span>
0123       [ab,ci,ok] = <a href="#_sub4" class="code" title="subfunction [ab,ci,ok] = fitENV(logx,logy,weights,order,refqtls)">fitENV</a>(logx,logy,weights,order,refqtls);
0124 <span class="keyword">end</span>
0125 
0126 
0127 <span class="comment">% NOW THAT FITTING IS DONE, SELECT THE FINAL FIT</span>
0128 [Fit,ok] = <a href="#_sub7" class="code" title="subfunction [Fit,ok] = evalFit(ab,x,y,ci,ok)">evalFit</a>(ab,x,y,ci,ok);
0129 
0130 <span class="keyword">if</span> exist(<span class="string">'fs'</span>,<span class="string">'var'</span>)
0131    Fit.fselect = s;
0132 <span class="keyword">end</span>
0133 
0134 <span class="keyword">if</span> plotfit == true
0135    Fit.h = bfra.pointcloudplot(q,dqdt,<span class="string">'reflines'</span>,{<span class="string">'userfit'</span>}, <span class="keyword">...</span>
0136       <span class="string">'userab'</span>,ab,<span class="string">'mask'</span>,mask,<span class="string">'usertext'</span>,method);
0137 <span class="keyword">end</span>
0138 
0139 <span class="comment">%-------------------------------------------------------------------------------</span>
0140 <span class="comment">% FITTING METHODS</span>
0141 <span class="comment">%-------------------------------------------------------------------------------</span>
0142 <a name="_sub1" href="#_subfunctions" class="code">function [ab,ci,ok] = fitOLS(logx,logy,weights,alpha)</a>
0143 <span class="comment">% ordinary least squares linear regression in log-log</span>
0144 
0145 <span class="comment">% Set up fittype and options.</span>
0146 ft       = fittype(     <span class="string">'poly1'</span>                         );
0147 fopts    = fitoptions(  <span class="string">'Method'</span>, <span class="string">'LinearLeastSquares'</span>  );
0148 fopts    = setfield(fopts,<span class="string">'Weights'</span>,weights);
0149 [f, ~]   = fit( logx, logy, ft, fopts );
0150 ab       = fliplr(coeffvalues(f));
0151 
0152 <span class="comment">% transform a to linear space and package a/b</span>
0153 ab = [exp(ab(1)); ab(2)];
0154 
0155 <span class="comment">% transpose ci to be consistent with stats functions</span>
0156 ci = rot90(confint(f,alpha));
0157 ci(1,:)  = exp(ci(1,:));
0158 
0159 <span class="comment">% generic failure check</span>
0160 ok = all(isreal(ab));
0161 
0162 
0163 <a name="_sub2" href="#_subfunctions" class="code">function [ab,ci,ok] = fitLIN(logx,logy,weights,alpha,order,fitopts)</a>
0164 <span class="comment">% linear model fit in log-log, equivalent to forcing a line of slope 1 through</span>
0165 <span class="comment">% the mean x-y, with option to control the slope using input parameter 'order'</span>
0166 
0167 <span class="comment">% check fitopts</span>
0168 <span class="keyword">if</span> isfield(fitopts,<span class="string">'order'</span>)
0169    <span class="keyword">if</span> isnumeric(fitopts.order); order = fitopts.order; <span class="keyword">end</span>
0170 <span class="keyword">end</span>
0171 
0172 <span class="comment">% apply the mask / weights</span>
0173 logx = logx(weights&gt;0);
0174 logy = logy(weights&gt;0);
0175 
0176 <span class="comment">% impose model order if provided</span>
0177 <span class="keyword">if</span> ~isnan(order)
0178    logx = order.*logx;
0179 <span class="keyword">end</span>
0180 
0181 [~,~,ci] = ttest(-logx,-logy,<span class="string">'Alpha'</span>,1-alpha);
0182 
0183 <span class="comment">% note: mean(x-y) = mean(x)-mean(y)</span>
0184 ab = [exp(-(mean(logx)-mean(logy))); order];
0185 
0186 <span class="comment">% transpose ci to be consistent with stats functions</span>
0187 ci = [exp(ci(1)) exp(ci(2)); ab(2), ab(2)];
0188 
0189 <span class="comment">% generic failure check</span>
0190 ok = all(isreal(ab));
0191 
0192 
0193 <a name="_sub3" href="#_subfunctions" class="code">function [ab,ci,ok] = fitMED(logx,logy,weights,order,fitopts)</a>
0194 <span class="comment">% force a line of slope 'order' through the median x-y</span>
0195 
0196 <span class="comment">% % not sure why this was here, order is passed in with default 1, maybe i was</span>
0197 <span class="comment">% gonna do away wiht that or maybe i was testing here before implementing that</span>
0198 <span class="comment">% order = 1;</span>
0199 <span class="comment">% if isfield(fitopts,'order')</span>
0200 <span class="comment">%    order = fitopts.order;</span>
0201 <span class="comment">% end</span>
0202 
0203 <span class="comment">% apply the mask / weights</span>
0204 logx = logx(weights&gt;0);
0205 logy = logy(weights&gt;0);
0206 
0207 logx = order*logx;
0208 pval = signrank(-logx,-logy); <span class="comment">% or ranksum or kruskalwallis</span>
0209 
0210 <span class="comment">% med(x-y)!=med(x)-med(y)</span>
0211 ab = [exp(-(median(logx)-median(logy))); order];
0212 
0213 <span class="comment">% non-parametric test, no ci</span>
0214 ci = [ab(1), ab(1); ab(2), ab(2)];
0215 
0216 <span class="comment">% could return to this later</span>
0217 <span class="comment">%bootfun  = @(x,y)(median(y)-median(x));</span>
0218 <span class="comment">%bootci(100,bootfun(logx,logy))</span>
0219 
0220 <span class="comment">% generic failure check</span>
0221 ok = all(isreal(ab));
0222 
0223 
0224 <a name="_sub4" href="#_subfunctions" class="code">function [ab,ci,ok] = fitENV(logx,logy,weights,order,refqtls)</a>
0225 <span class="comment">% force a line of slope 'order' through any two points 'refpoints' that</span>
0226 <span class="comment">% together define an 'envelope'. default x refpoint is median(x). To control</span>
0227 <span class="comment">% the vertical location of the line, set y refpoint higher or lower while</span>
0228 <span class="comment">% keeping x refpoint constant.</span>
0229 
0230 <span class="comment">% note: require that quantiles are passed in rather than precomputed refpoints</span>
0231 <span class="comment">% so this can use the log values or linear values</span>
0232 
0233 <span class="comment">% % removed fitopts for now</span>
0234 <span class="comment">%    % check fitopts</span>
0235 <span class="comment">%       if isfield(fitopts,'order')</span>
0236 <span class="comment">%          if isnumeric(fitopts.order); order = fitopts.order; end</span>
0237 <span class="comment">%       end</span>
0238 <span class="comment">%</span>
0239 <span class="comment">%       if isfield(fitopts,'quantile')</span>
0240 <span class="comment">%          quantile = fitopts.quantile;</span>
0241 <span class="comment">%       end</span>
0242 
0243 <span class="comment">% apply the mask / weights</span>
0244 logx = logx(weights&gt;0);
0245 logy = logy(weights&gt;0);
0246 
0247 logx = order.*logx;
0248 
0249 <span class="comment">% force the line through the provided quantile</span>
0250 xbar = quantile(logx,refqtls(1),<span class="string">'Method'</span>,<span class="string">'approximate'</span>);
0251 ybar = quantile(logy,refqtls(2),<span class="string">'Method'</span>,<span class="string">'approximate'</span>);
0252 
0253 <span class="comment">% note: mean(x-y) = mean(x)-mean(y)</span>
0254 ab = [ exp(-(xbar-ybar)); order];
0255 
0256 <span class="comment">% transpose ci to be consistent with stats functions</span>
0257 ci = [nan nan; nan, nan];
0258 
0259 <span class="comment">% generic failure check</span>
0260 ok = all(isreal(ab));
0261 
0262 
0263 <a name="_sub5" href="#_subfunctions" class="code">function [ab,ci,ok] = fitQTL(logx,logy,weights,alpha,order,quantile,Nboot,fitopts)</a>
0264 
0265 <span class="comment">% quantile regression</span>
0266 <span class="keyword">if</span> isfield(fitopts,<span class="string">'quantile'</span>)
0267    quantile =  fitopts.pctl;
0268    order    =  fitopts.order; <span class="comment">% 1=linear regression</span>
0269    Nboot    =  fitopts.Nboot;
0270    <span class="comment">% alpha    =  fitopts.alpha;</span>
0271 <span class="keyword">elseif</span> isnan(quantile)
0272    quantile = 0.05;
0273 <span class="keyword">end</span>
0274 
0275 <span class="comment">% apply the mask / weights</span>
0276 logx = logx(weights&gt;0);
0277 logy = logy(weights&gt;0);
0278 
0279 <span class="comment">% fit a,b using quantile regression</span>
0280 [ab,s] = bfra.deps.quantreg(logx,logy,quantile,order,Nboot,1-alpha);
0281 
0282 <span class="comment">% transform a to linear space and package a/b</span>
0283 ab = [exp(ab(1)); ab(2)];
0284 
0285 <span class="comment">% transpose ci to be consistent with stats functions</span>
0286 ci = transpose(s.ci_boot);   <span class="comment">% comes in the same order as confint</span>
0287 ci(1,:) = exp(ci(1,:));
0288 
0289 <span class="comment">% generic failure check</span>
0290 ok = all(isreal(ab));
0291 
0292 
0293 <span class="comment">% function [ab,ci,ok] = fitMLE(logx,logy,weights,alpha,sigx,sigy,rxy)</span>
0294 <span class="comment">%</span>
0295 <span class="comment">% % Set default values for maximum likelihood estimation</span>
0296 <span class="comment">% if nargin == 2</span>
0297 <span class="comment">%    sigx     =  std(logx);       % error in x</span>
0298 <span class="comment">%    sigy     =  std(logy);       % error in y</span>
0299 <span class="comment">%    rxy      =  0;               % correlation b/w error in x and y</span>
0300 <span class="comment">%    alpha    =  0.68;            % confidence level</span>
0301 <span class="comment">% end</span>
0302 <span class="comment">%</span>
0303 <span class="comment">% % fit</span>
0304 <span class="comment">% [ab,s] = yorkfit(logx,logy,sigx,sigy,rxy,1-alpha);</span>
0305 <span class="comment">%</span>
0306 <span class="comment">% ab = [exp(ab(1)); ab(2)];</span>
0307 <span class="comment">%</span>
0308 <span class="comment">% % transpose ci to be consistent with stats functions</span>
0309 <span class="comment">% ci = [exp(s.a_L), exp(s.a_H); s.b_L, s.b_H];</span>
0310 <span class="comment">%</span>
0311 <span class="comment">% % generic failure check</span>
0312 <span class="comment">% ok = true;</span>
0313 <span class="comment">% if any(~isreal(ab))</span>
0314 <span class="comment">%    ok = false;</span>
0315 <span class="comment">% end</span>
0316 
0317 
0318 <a name="_sub6" href="#_subfunctions" class="code">function [ab,ci,ok,fselect] = fitNLS(x,y,logx,logy,weights,alpha,fitopts)</a>
0319 
0320 warning off
0321 
0322 <span class="comment">% initial estimates using log-log linear fit</span>
0323 ci = [nan nan; nan nan];
0324 ok = true;
0325 ab0 = [ones(size(x)) logx]\logy;
0326 ab0 = [exp(ab0(1)), ab0(2)];
0327 
0328 <span class="comment">% iniital rsq</span>
0329 rsq0 = bfra.deps.rsquare(y,ab0(1).*x.^ab0(2)); rsq = rsq0;
0330 
0331 <span class="comment">% to use user-specified weights:</span>
0332 <span class="comment">%opts = statset('Display','off','RobustWgtFun',[]);</span>
0333 <span class="comment">%ab = nlinfit(q,dqdt,fnc,ab0,opts,'Weights',weights);</span>
0334 
0335 <span class="comment">% 'nlinfit' function options</span>
0336 fnc = @(ab,x)ab(1).*x.^ab(2);
0337 
0338 <span class="comment">% fnc = @(ab,x)ab(1).^(3-2.*ab(2)).*x.^ab(2);</span>
0339 
0340 opts1 = statset(<span class="string">'Display'</span>,<span class="string">'off'</span>,<span class="string">'RobustWgtFun'</span>,<span class="string">'bisquare'</span>);
0341 opts2 = statset(<span class="string">'Display'</span>,<span class="string">'off'</span>);
0342 
0343 <span class="comment">% 'fit' function options</span>
0344 ftype = fittype(@(a,b,x) (a.*x.^b));
0345 
0346 opts3 = fitoptions(<span class="string">'Method'</span>,<span class="string">'NonlinearLeastSquares'</span>,<span class="string">'Display'</span>,<span class="keyword">...</span>
0347    <span class="string">'off'</span>,<span class="string">'Robust'</span>,<span class="string">'Bisquare'</span>,<span class="string">'StartPoint'</span>,[ab0(1) ab0(2)]);
0348 
0349 opts4 = fitoptions(<span class="string">'Method'</span>,<span class="string">'NonlinearLeastSquares'</span>,          <span class="keyword">...</span>
0350    <span class="string">'Display'</span>,<span class="string">'off'</span>,<span class="string">'StartPoint'</span>,[ab0(1) ab0(2)]);
0351 
0352 <span class="comment">%  Summary of the method:</span>
0353 
0354 <span class="comment">%  start with linear=rsq0, set rsq=rsq0</span>
0355 <span class="comment">%  try nlinfit=rsq1, if rsq1&gt;rsq, set rsq=rsq1 and select nlinfit robust</span>
0356 <span class="comment">%  else, try fit=rsq3, if rsq3&gt;rsq, set rsq=rsq3 and select fit robust</span>
0357 <span class="comment">%  else, select 'none', rsq still equals rsq0</span>
0358 <span class="comment">%  if 'none', try non-robust nlinfit=rsq2, if rsq2&gt;rsq, set rsq=rsq2 and</span>
0359 <span class="comment">%  select nlinfit non-robust</span>
0360 <span class="comment">%  else</span>
0361 
0362 <span class="comment">% warning off</span>
0363 <span class="comment">% try robust nonlinear least squares fitting</span>
0364 ab1ok = true;
0365 <span class="keyword">try</span>
0366    [ab1,R1,~,C1] = nlinfit(x,y,fnc,ab0,opts1); <span class="comment">% R=resids,C=error variance</span>
0367    rsq1 = bfra.deps.rsquare(y,ab1(1).*x.^ab1(2));
0368    
0369 <span class="keyword">catch</span> ME
0370    
0371    <span class="keyword">if</span> (strcmp(ME.identifier,<span class="string">'stats:nlinfit:NoUsableObservations'</span>))
0372       
0373       msg = <span class="string">'Fitting failed using nlinfit at ab1'</span>;
0374       causeException = MException(<span class="string">'BFRA:fitab:fitting'</span>,msg);
0375       ME = addCause(ME,causeException);
0376       
0377    <span class="keyword">end</span>
0378    ab1ok = false;
0379    <span class="comment">% rethrow(ME)</span>
0380 <span class="keyword">end</span>
0381 
0382 
0383 
0384 <span class="comment">% if nlinfit worked and it's 'better' than rsq (here, rsq0), select it</span>
0385 <span class="keyword">if</span> ab1ok &amp;&amp; rsq1 &gt; rsq &amp;&amp; rsq1 &gt; 0
0386    
0387    fselect = <span class="string">'nlinfit_robust'</span>;
0388    rsq = rsq1;
0389    
0390 <span class="keyword">else</span>
0391    
0392    <span class="comment">% try curve fitting functions</span>
0393    ab3ok = true;
0394    <span class="keyword">try</span>
0395       
0396       f3 = fit(x,y,ftype,opts3); 
0397       ab3 = coeffvalues(f3);
0398       rsq3 = bfra.deps.rsquare(y,ab3(1).*x.^ab3(2));
0399       
0400    <span class="keyword">catch</span> ME
0401       
0402       <span class="keyword">if</span> (strcmp(ME.identifier,<span class="string">'curvefit:fit:infComputed'</span>))
0403          
0404          msg = <span class="string">'Fitting failed using fit at ab3'</span>;
0405          causeException = MException(<span class="string">'BFRA:fitab:fitting'</span>,msg);
0406          ME = addCause(ME,causeException);
0407       <span class="keyword">end</span>
0408       ab3ok = false;
0409       <span class="comment">% rethrow(ME)</span>
0410    <span class="keyword">end</span>
0411    
0412    
0413    
0414    <span class="comment">% if fit worked, select it</span>
0415    <span class="keyword">if</span> ab3ok &amp;&amp; rsq3 &gt; rsq &amp;&amp; rsq3 &gt; 0
0416       
0417       fselect = <span class="string">'fit_robust'</span>;
0418       rsq = rsq3;
0419    <span class="keyword">else</span>
0420       fselect = <span class="string">'none'</span>;
0421       
0422    <span class="keyword">end</span>
0423 <span class="keyword">end</span>
0424 
0425 
0426 
0427 <span class="comment">% if neither nlinfit nor fit worked, try non-robust fitting</span>
0428 <span class="keyword">if</span> strcmp(fselect,<span class="string">'none'</span>)
0429    
0430    ab2ok = true;
0431    <span class="keyword">try</span>
0432       [ab2,R2,~,C2] = nlinfit(x,y,fnc,ab0,opts2);
0433       rsq2 = bfra.deps.rsquare(y,ab2(1).*x.^ab2(2));
0434       
0435    <span class="keyword">catch</span> ME
0436       
0437       <span class="keyword">if</span> (strcmp(ME.identifier,<span class="string">'stats:nlinfit:NoUsableObservations'</span>))
0438          
0439          msg = <span class="string">'Fitting failed using nlinfit at ab2'</span>;
0440          causeException = MException(<span class="string">'BFRA:fitab:fitting'</span>,msg);
0441          ME = addCause(ME,causeException);
0442       <span class="keyword">end</span>
0443       ab2ok = false;
0444       <span class="comment">%rethrow(ME)</span>
0445    <span class="keyword">end</span>
0446    
0447    
0448    <span class="keyword">if</span> ab2ok &amp;&amp; rsq2 &gt; rsq &amp;&amp; rsq2 &gt; 0
0449       
0450       fselect = <span class="string">'nlinfit'</span>;
0451       rsq = rsq2;
0452       
0453    <span class="keyword">else</span>                            <span class="comment">% try curve fitting functions</span>
0454       
0455       ab4ok = true;
0456       <span class="keyword">try</span>
0457          f4 = fit(x,y,ftype,opts4); ab4 = coeffvalues(f4);
0458          rsq4 = bfra.deps.rsquare(y,ab4(1).*x.^ab4(2));
0459          
0460       <span class="keyword">catch</span> ME
0461          
0462          <span class="keyword">if</span> (strcmp(ME.identifier,<span class="string">'curvefit:fit:infComputed'</span>))
0463             
0464             msg = <span class="string">'Fitting failed using fit at ab4'</span>;
0465             causeException = MException(<span class="string">'BFRA:fitab:fitting'</span>,msg);
0466             ME = addCause(ME,causeException);
0467          <span class="keyword">end</span>
0468          ab4ok = false;
0469          <span class="comment">%rethrow(ME)</span>
0470       <span class="keyword">end</span>
0471       
0472       
0473       
0474       <span class="comment">% we don't compare with rsq2 because we already know its &lt;rsq0</span>
0475       <span class="keyword">if</span> ab4ok &amp;&amp; rsq4 &gt; rsq &amp;&amp; rsq4 &gt; 0
0476          
0477          fselect = <span class="string">'fit'</span>;
0478          rsq = rsq4;
0479       <span class="keyword">else</span>
0480          fselect = <span class="string">'none'</span>;
0481       <span class="keyword">end</span>
0482    <span class="keyword">end</span>
0483    
0484    
0485 <span class="keyword">end</span>
0486 
0487 <span class="comment">% finally, if rsq is still low but linear rsq is good, choose lin</span>
0488 <span class="keyword">if</span> strcmp(fselect,<span class="string">'none'</span>) &amp;&amp; rsq &gt; 0
0489    
0490    fselect = <span class="string">'linear'</span>;
0491 <span class="keyword">elseif</span> rsq &lt; 0
0492    <span class="comment">% NOTE: nov 2022, i think in some cases we can get here and rsq &lt; 0 so I</span>
0493    <span class="comment">% added this option , previously there was no else, just end</span>
0494    fselect = <span class="string">'none'</span>;
0495 <span class="keyword">end</span>
0496 
0497 <span class="keyword">switch</span> fselect
0498    
0499    <span class="keyword">case</span> <span class="string">'none'</span>
0500       ok = false;   <span class="comment">% should never occur with option linear</span>
0501       ab = [nan,nan]; <span class="comment">% turns out can occur if q vs dqdt is decreasing</span>
0502       
0503    <span class="keyword">case</span> <span class="string">'nlinfit_robust'</span>
0504       ci = nlparci(ab1,R1,<span class="string">'covariance'</span>,C1,<span class="string">'alpha'</span>,alpha);
0505       ab = ab1;
0506       
0507    <span class="keyword">case</span> <span class="string">'nlinfit'</span>
0508       ci = nlparci(ab2,R2,<span class="string">'covariance'</span>,C2,<span class="string">'alpha'</span>,0.68);
0509       ab = ab2;
0510       
0511    <span class="keyword">case</span> <span class="string">'fit_robust'</span>
0512       ab = ab3;
0513       ci = transpose(confint(f3,alpha));
0514       
0515    <span class="keyword">case</span> <span class="string">'fit'</span>
0516       ab = ab4;
0517       ci = transpose(confint(f4,alpha));
0518       
0519    <span class="keyword">case</span> <span class="string">'linear'</span>
0520       
0521       [ab,ci] = regress(logy,[ones(size(y)) logx]);
0522       ci(1,:) = exp(ci(1,:));
0523       ab = [exp(ab(1)); ab(2)];
0524       
0525       <span class="comment">% might check metrics such as islineconvex(y), and if x&lt;xmin where</span>
0526       <span class="comment">% xmin is some very small flow value below which the data is corrupt</span>
0527 <span class="keyword">end</span>
0528 
0529 
0530 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0531 <span class="comment">% the original method was here</span>
0532 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0533 
0534 
0535 <a name="_sub7" href="#_subfunctions" class="code">function [Fit,ok] = evalFit(ab,x,y,ci,ok)</a>
0536 
0537 warning off <span class="comment">% otherwise rsquare issues warning</span>
0538 
0539 Fit.ab = ab;
0540 
0541 <span class="comment">% all ci's should already be transformed to this form:</span>
0542 Fit.a = ab(1);
0543 Fit.b = ab(2);
0544 Fit.aL = ci(1,1);
0545 Fit.aH = ci(1,2);
0546 Fit.bL = ci(2,1);
0547 Fit.bH = ci(2,2);
0548 
0549 Fit.rsq = bfra.deps.rsquare(y,ab(1).*x.^ab(2));
0550 Fit.pvalue = nan;
0551 Fit.N = numel(y);
0552 Fit.x = x;
0553 Fit.y = y;
0554 
0555 <span class="comment">% generic failure check</span>
0556 ok = all(isreal(ab));
0557 
0558 warning on
0559 
0560 <span class="comment">%    % any log-log regressions need the ci's transormed like this:</span>
0561 <span class="comment">%    aL      = exp(ci(1,1)); % 95% CI</span>
0562 <span class="comment">%    aH      = exp(ci(1,2));</span>
0563 <span class="comment">%    bL      = ci(2,1);      % = betaL</span>
0564 <span class="comment">%    bH      = ci(2,2);      % = betaH</span>
0565 
0566 <span class="comment">%    % any nlinfit regressions should already be in teh right order:</span>
0567 <span class="comment">%    aL      = ci(1,1); % for confint: ci(1,1);</span>
0568 <span class="comment">%    aH      = ci(1,2); % for confint: ci(2,1);</span>
0569 <span class="comment">%    bL      = ci(2,1); % for confint: ci(1,2);</span>
0570 <span class="comment">%    bH      = ci(2,2); % for confint: ci(2,2);</span>
0571 
0572 <span class="comment">% this does not work if robust fitting is used</span>
0573 <span class="comment">%r2      = 1-sum(R.^2)/sum((y-mean(y)).^2); % for fit: gof.rsquare;</span>
0574 <span class="comment">%figure; loglog(x,y,'o'); hold on; loglog(x,ab(1).*x.^ab(2))</span>
0575</pre></div>
</body>
</html>