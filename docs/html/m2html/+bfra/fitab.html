<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of fitab</title>
  <meta name="keywords" content="fitab">
  <meta name="description" content="FITAB fit event-scale recession equation -dq/dt = aQ^b">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../function_index.html">Home</a> &gt;  <a href="function_index.html">+bfra</a> &gt; fitab.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../function_index.html"><img alt="<" border="0" src="../html_img/left.png">&nbsp;Master index</a></td>
<td align="right"><a href="function_index.html">Index for +bfra&nbsp;<img alt=">" border="0" src="../html_img/right.png"></a></td></tr></table>-->

<h1>fitab
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../html_img/up.png"></a></h2>
<div class="box"><strong>FITAB fit event-scale recession equation -dq/dt = aQ^b</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../html_img/up.png"></a></h2>
<div class="box"><strong>function [Fit,ok] = fitab(q,dqdt,method,varargin) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../html_img/up.png"></a></h2>
<div class="fragment"><pre class="comment">FITAB fit event-scale recession equation -dq/dt = aQ^b

 Syntax

     [Fit,ok] = fitab(q,dqdt,method,varargin)

 Description

     [Fit,ok] = fitab(q,dqdt,method) fits event-scale recession equation
     -dq/dt = aQ^b to estimate parameters a and b using the specified fitting
     method. Valid methods are ordinary least squares (ols), non-linear least
     squares (nls), quantile regression (qtl), mean difference ('mean'), median
     difference ('median').

 Required inputs

     q        vector double of discharge data (L T^-1)
     dqdt     vector double of discharge rate of change (L T^-2)
     method   char indicating the fitting method

 Optional inputs

     weights  vector double of weights for the fitting algorithm
     mask     vector logical mask to exclude values from fitting
     order    scalar, exponent in -dq/dt = aQ^b
     refqtls  2x1 double, x/y quantiles used if 'method' == 'envelope'
     quantile scalar double, quantile used if 'method' == 'qtl' (quantile regression)
     Nboot    scalar double, bootstrap sample size for quantile regression
     plotfit  logical scalar indicating whether to make a plot or not
     fitopts  struct containing fitting options (not currently implemented)

 Notes 
     weights are set zero anywhere mask is false
 
     Use method 'envelope' to pass a line through an arbitrary x,y pair
     (refpoints), specified in terms of the quantile of the x/y data
     distributions. this method is similar to 'mean' or 'median', but allows
     different ref points for the x/y values, for example the median of the x
     values (0.50 quantile) and some other quantile of the y values. The
     default (recommended) behavior is to keep the x-quantile = 0.5 and vary
     the y-quantile to move the line up and down as desired to define an
     &quot;envelope&quot;
 
 See also <a href="prepfits.html" class="code" title="function [x,y,logx,logy,w,ok] = prepfits(q,dqdt,varargin)">prepfits</a>

 Matt Cooper, 04-Nov-2022, https://github.com/mgcooper</pre></div>


<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../html_img/up.png"></a></h2>

This function calls:
<ul style="list-style-image:url(../html_img/matlabicon.gif)">
</ul>


This function is called by:
<ul style="list-style-image:url(../html_img/matlabicon.gif)">
</ul>
<!-- crossreference -->


<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../html_img/up.png"></a></h2>
<ul style="list-style-image:url(../html_img/matlabicon.gif)">

<li><a href="#_sub1" class="code">function [ab,ci,ok] = fitOLS(logx,logy,weights,alpha,inoctave)</a></li>
<li><a href="#_sub2" class="code">function [ab,ci,ok] = fitLIN(logx,logy,weights,alpha,order,inoctave)</a></li>
<li><a href="#_sub3" class="code">function [ab,ci,ok] = fitMED(logx,logy,weights,order,inoctave)</a></li>
<li><a href="#_sub4" class="code">function [ab,ci,ok] = fitENV(logx,logy,weights,order,refqtls,inoctave)</a></li>
<li><a href="#_sub5" class="code">function [ab,ci,ok] = fitQTL(logx,logy,weights,alpha,order,qtl,Nboot,inoctave)</a></li>
<li><a href="#_sub6" class="code">function [ab,ci,ok,fselect] = fitNLS(x,y,logx,logy,weights,alpha,inoctave)</a></li>
<li><a href="#_sub7" class="code">function [Fit,ok] = evalFit(ab,x,y,ci,ok)</a></li>
<li><a href="#_sub8" class="code">function [ab,ci,ok,fselect] = fitNLS_matlab(x,y,logx,logy,weights,alpha)</a></li>
<li><a href="#_sub9" class="code">function [ab,ci,ok,fselect] = fitNLS_octave(x,y,logx,logy,weights,alpha)</a></li>
<li><a href="#_sub10" class="code">function ci = nlparci_octave(beta, CovB, alpha)</a></li>
<li><a href="#_sub11" class="code">function [weights, order, mask, qtl, refqtls, Nboot, alpha, plotfit] =</a></li></ul>



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../html_img/up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [Fit,ok] = fitab(q,dqdt,method,varargin)</a>
0002 <span class="comment">%FITAB fit event-scale recession equation -dq/dt = aQ^b</span>
0003 <span class="comment">%</span>
0004 <span class="comment">% Syntax</span>
0005 <span class="comment">%</span>
0006 <span class="comment">%     [Fit,ok] = fitab(q,dqdt,method,varargin)</span>
0007 <span class="comment">%</span>
0008 <span class="comment">% Description</span>
0009 <span class="comment">%</span>
0010 <span class="comment">%     [Fit,ok] = fitab(q,dqdt,method) fits event-scale recession equation</span>
0011 <span class="comment">%     -dq/dt = aQ^b to estimate parameters a and b using the specified fitting</span>
0012 <span class="comment">%     method. Valid methods are ordinary least squares (ols), non-linear least</span>
0013 <span class="comment">%     squares (nls), quantile regression (qtl), mean difference ('mean'), median</span>
0014 <span class="comment">%     difference ('median').</span>
0015 <span class="comment">%</span>
0016 <span class="comment">% Required inputs</span>
0017 <span class="comment">%</span>
0018 <span class="comment">%     q        vector double of discharge data (L T^-1)</span>
0019 <span class="comment">%     dqdt     vector double of discharge rate of change (L T^-2)</span>
0020 <span class="comment">%     method   char indicating the fitting method</span>
0021 <span class="comment">%</span>
0022 <span class="comment">% Optional inputs</span>
0023 <span class="comment">%</span>
0024 <span class="comment">%     weights  vector double of weights for the fitting algorithm</span>
0025 <span class="comment">%     mask     vector logical mask to exclude values from fitting</span>
0026 <span class="comment">%     order    scalar, exponent in -dq/dt = aQ^b</span>
0027 <span class="comment">%     refqtls  2x1 double, x/y quantiles used if 'method' == 'envelope'</span>
0028 <span class="comment">%     quantile scalar double, quantile used if 'method' == 'qtl' (quantile regression)</span>
0029 <span class="comment">%     Nboot    scalar double, bootstrap sample size for quantile regression</span>
0030 <span class="comment">%     plotfit  logical scalar indicating whether to make a plot or not</span>
0031 <span class="comment">%     fitopts  struct containing fitting options (not currently implemented)</span>
0032 <span class="comment">%</span>
0033 <span class="comment">% Notes</span>
0034 <span class="comment">%     weights are set zero anywhere mask is false</span>
0035 <span class="comment">%</span>
0036 <span class="comment">%     Use method 'envelope' to pass a line through an arbitrary x,y pair</span>
0037 <span class="comment">%     (refpoints), specified in terms of the quantile of the x/y data</span>
0038 <span class="comment">%     distributions. this method is similar to 'mean' or 'median', but allows</span>
0039 <span class="comment">%     different ref points for the x/y values, for example the median of the x</span>
0040 <span class="comment">%     values (0.50 quantile) and some other quantile of the y values. The</span>
0041 <span class="comment">%     default (recommended) behavior is to keep the x-quantile = 0.5 and vary</span>
0042 <span class="comment">%     the y-quantile to move the line up and down as desired to define an</span>
0043 <span class="comment">%     &quot;envelope&quot;</span>
0044 <span class="comment">%</span>
0045 <span class="comment">% See also prepfits</span>
0046 <span class="comment">%</span>
0047 <span class="comment">% Matt Cooper, 04-Nov-2022, https://github.com/mgcooper</span>
0048 
0049 <span class="comment">% if called with no input, open this file</span>
0050 <span class="keyword">if</span> nargin == 0; open(mfilename(<span class="string">'fullpath'</span>)); <span class="keyword">return</span>; <span class="keyword">end</span>
0051 
0052 <span class="keyword">persistent</span> inoctave
0053 <span class="keyword">if</span> isempty(inoctave); inoctave = exist(&quot;OCTAVE_VERSION&quot;, &quot;builtin&quot;)&gt;0;
0054 <span class="keyword">end</span>
0055 
0056 <span class="comment">% PARSE INPUTS</span>
0057 [weights, order, mask, qtl, refqtls, Nboot, alpha, plotfit] = parseinputs( <span class="keyword">...</span>
0058    q, dqdt, method, mfilename, varargin{:});
0059 
0060 <span class="comment">% PREP FITS</span>
0061 [x, y, logx, logy, weights, ok] = bfra.prepfits( <span class="keyword">...</span>
0062    q, dqdt, <span class="string">'weights'</span>, weights, <span class="string">'mask'</span>, mask);
0063 
0064 <span class="comment">% FAST EXIT</span>
0065 <span class="keyword">if</span> ok == false
0066    Fit = nan; <span class="keyword">return</span>;
0067 <span class="keyword">end</span>
0068 
0069 <span class="comment">% If method = 'ols' and 'order' = 1, use method 'mean' with a line of slope 1</span>
0070 <span class="keyword">if</span> strcmp(method,<span class="string">'ols'</span>) &amp;&amp; order == 1
0071    method = <span class="string">'mean'</span>;
0072 <span class="keyword">end</span>
0073 
0074 <span class="comment">% SWITCH YARD</span>
0075 fselect = method;
0076 
0077 <span class="keyword">switch</span> method
0078    <span class="keyword">case</span> <span class="string">'ols'</span>
0079       [ab,ci,ok] = <a href="#_sub1" class="code" title="subfunction [ab,ci,ok] = fitOLS(logx,logy,weights,alpha,inoctave)">fitOLS</a>(logx,logy,weights,alpha,inoctave);
0080    <span class="keyword">case</span> <span class="string">'qtl'</span>
0081       [ab,ci,ok] = <a href="#_sub5" class="code" title="subfunction [ab,ci,ok] = fitQTL(logx,logy,weights,alpha,order,qtl,Nboot,inoctave)">fitQTL</a>(logx,logy,weights,alpha,order,qtl,Nboot,inoctave);
0082    <span class="keyword">case</span> <span class="string">'mle'</span>
0083       error(<span class="string">'mle fitting not currently supported'</span>);
0084       <span class="comment">% [ab,ci,ok] = fitMLE(logx,logy,weights,alpha,sigx,sigy,rxy);</span>
0085    <span class="keyword">case</span> <span class="string">'nls'</span>
0086       [ab,ci,ok,fselect] = <a href="#_sub6" class="code" title="subfunction [ab,ci,ok,fselect] = fitNLS(x,y,logx,logy,weights,alpha,inoctave)">fitNLS</a>(x,y,logx,logy,weights,alpha,inoctave);
0087    <span class="keyword">case</span> <span class="string">'mean'</span>
0088       [ab,ci,ok] = <a href="#_sub2" class="code" title="subfunction [ab,ci,ok] = fitLIN(logx,logy,weights,alpha,order,inoctave)">fitLIN</a>(logx,logy,weights,alpha,order,inoctave);
0089    <span class="keyword">case</span> <span class="string">'median'</span>
0090       [ab,ci,ok] = <a href="#_sub3" class="code" title="subfunction [ab,ci,ok] = fitMED(logx,logy,weights,order,inoctave)">fitMED</a>(logx,logy,weights,order,inoctave);
0091    <span class="keyword">case</span> <span class="string">'envelope'</span>
0092       [ab,ci,ok] = <a href="#_sub4" class="code" title="subfunction [ab,ci,ok] = fitENV(logx,logy,weights,order,refqtls,inoctave)">fitENV</a>(logx,logy,weights,order,refqtls,inoctave);
0093 <span class="keyword">end</span>
0094 
0095 <span class="comment">% EVALUATE THE FIT</span>
0096 [Fit,ok] = <a href="#_sub7" class="code" title="subfunction [Fit,ok] = evalFit(ab,x,y,ci,ok)">evalFit</a>(ab,x,y,ci,ok);
0097 
0098 <span class="keyword">if</span> exist(<span class="string">'fselect'</span>,<span class="string">'var'</span>)
0099    Fit.fselect = fselect;
0100 <span class="keyword">end</span>
0101 
0102 <span class="keyword">if</span> plotfit == true
0103    Fit.h = bfra.pointcloudplot(q,dqdt,<span class="string">'reflines'</span>,{<span class="string">'userfit'</span>}, <span class="keyword">...</span>
0104       <span class="string">'userab'</span>,ab,<span class="string">'mask'</span>,mask,<span class="string">'usertext'</span>,method);
0105 <span class="keyword">end</span>
0106 
0107 
0108 <span class="comment">% FITTING METHODS</span>
0109 <a name="_sub1" href="#_subfunctions" class="code">function [ab,ci,ok] = fitOLS(logx,logy,weights,alpha,inoctave)</a>
0110 <span class="comment">% ordinary least squares linear regression in log-log</span>
0111 
0112 <span class="comment">% TODO: replace this with octave compatible fitting</span>
0113 
0114 <span class="comment">% Set up fittype and options.</span>
0115 <span class="keyword">if</span> inoctave
0116    error(<span class="string">'ordinary least squares not currently supported in octave, use nls'</span>)
0117 <span class="keyword">else</span>
0118    ft = fittype(<span class="string">'poly1'</span>);
0119    fopts = fitoptions( <span class="string">'Method'</span>, <span class="string">'LinearLeastSquares'</span>);
0120    fopts = setfield(fopts,<span class="string">'Weights'</span>, weights);
0121    [f,~] = fit( logx, logy, ft, fopts );
0122    ab = fliplr(coeffvalues(f));
0123 <span class="keyword">end</span>
0124 
0125 <span class="comment">% transform a to linear space and package a/b</span>
0126 ab = [exp(ab(1)); ab(2)];
0127 
0128 <span class="comment">% transpose ci to be consistent with stats functions</span>
0129 ci = rot90(confint(f,alpha));
0130 ci(1,:) = exp(ci(1,:));
0131 
0132 <span class="comment">% generic failure check</span>
0133 ok = all(isreal(ab));
0134 
0135 
0136 <a name="_sub2" href="#_subfunctions" class="code">function [ab,ci,ok] = fitLIN(logx,logy,weights,alpha,order,inoctave)</a>
0137 <span class="comment">% linear model fit in log-log, equivalent to forcing a line of slope 1 through</span>
0138 <span class="comment">% the mean x-y, with option to control the slope using input parameter 'order'</span>
0139 
0140 <span class="comment">% % not sure if this was ever functional</span>
0141 <span class="comment">% % check fitopts</span>
0142 <span class="comment">% if isfield(fitopts,'order')</span>
0143 <span class="comment">%    if isnumeric(fitopts.order); order = fitopts.order; end</span>
0144 <span class="comment">% end</span>
0145 
0146 <span class="comment">% apply the mask / weights</span>
0147 logx = logx(weights&gt;0);
0148 logy = logy(weights&gt;0);
0149 
0150 <span class="comment">% impose model order if provided</span>
0151 <span class="keyword">if</span> ~isnan(order)
0152    logx = order.*logx;
0153 <span class="keyword">end</span>
0154 
0155 [~,~,ci] = ttest(-logx,-logy,<span class="string">'Alpha'</span>,1-alpha);
0156 
0157 <span class="comment">% note: mean(x-y) = mean(x)-mean(y)</span>
0158 ab = [exp(-(mean(logx)-mean(logy))); order];
0159 
0160 <span class="comment">% transpose ci to be consistent with stats functions</span>
0161 ci = [exp(ci(1)) exp(ci(2)); ab(2), ab(2)];
0162 
0163 <span class="comment">% generic failure check</span>
0164 ok = all(isreal(ab));
0165 
0166 
0167 <a name="_sub3" href="#_subfunctions" class="code">function [ab,ci,ok] = fitMED(logx,logy,weights,order,inoctave)</a>
0168 <span class="comment">% force a line of slope 'order' through the median x-y</span>
0169 
0170 <span class="comment">% % not sure why this was here, order is passed in with default 1, maybe i was</span>
0171 <span class="comment">% gonna do away wiht that or maybe i was testing here before implementing that</span>
0172 <span class="comment">% order = 1;</span>
0173 <span class="comment">% if isfield(fitopts,'order')</span>
0174 <span class="comment">%    order = fitopts.order;</span>
0175 <span class="comment">% end</span>
0176 
0177 <span class="comment">% apply the mask / weights</span>
0178 logx = logx(weights&gt;0);
0179 logy = logy(weights&gt;0);
0180 
0181 logx = order*logx;
0182 
0183 <span class="keyword">if</span> inoctave
0184    pval = nan; <span class="comment">% ranksum and kruskalwallis both supported, need to implement</span>
0185 <span class="keyword">else</span>
0186    pval = signrank(-logx,-logy); <span class="comment">% or ranksum or kruskalwallis</span>
0187 <span class="keyword">end</span>
0188 
0189 <span class="comment">% med(x-y)!=med(x)-med(y)</span>
0190 ab = [exp(-(median(logx)-median(logy))); order];
0191 
0192 <span class="comment">% non-parametric test, no ci</span>
0193 ci = [ab(1), ab(1); ab(2), ab(2)];
0194 
0195 <span class="comment">% could return to this later</span>
0196 <span class="comment">%bootfun = @(x,y)(median(y)-median(x));</span>
0197 <span class="comment">%bootci(100,bootfun(logx,logy))</span>
0198 
0199 <span class="comment">% generic failure check</span>
0200 ok = all(isreal(ab));
0201 
0202 
0203 <a name="_sub4" href="#_subfunctions" class="code">function [ab,ci,ok] = fitENV(logx,logy,weights,order,refqtls,inoctave)</a>
0204 <span class="comment">% force a line of slope 'order' through any two points 'refpoints' that</span>
0205 <span class="comment">% together define an 'envelope'. default x refpoint is median(x). To control</span>
0206 <span class="comment">% the vertical location of the line, set y refpoint higher or lower while</span>
0207 <span class="comment">% keeping x refpoint constant.</span>
0208 
0209 <span class="comment">% note: require that quantiles are passed in rather than precomputed refpoints</span>
0210 <span class="comment">% so this can use the log values or linear values</span>
0211 
0212 <span class="comment">% % removed fitopts for now</span>
0213 <span class="comment">%    % check fitopts</span>
0214 <span class="comment">%       if isfield(fitopts,'order')</span>
0215 <span class="comment">%          if isnumeric(fitopts.order); order = fitopts.order; end</span>
0216 <span class="comment">%       end</span>
0217 <span class="comment">%</span>
0218 <span class="comment">%       if isfield(fitopts,'quantile')</span>
0219 <span class="comment">%          quantile = fitopts.quantile;</span>
0220 <span class="comment">%       end</span>
0221 
0222 <span class="comment">% apply the mask / weights</span>
0223 logx = logx(weights&gt;0);
0224 logy = logy(weights&gt;0);
0225 logx = order.*logx;
0226 
0227 <span class="comment">% force the line through the provided quantile</span>
0228 <span class="keyword">if</span> inoctave
0229    xbar = quantile(logx,refqtls(1),1,8);
0230    ybar = quantile(logy,refqtls(2),1,8);
0231 <span class="keyword">else</span>
0232    xbar = quantile(logx,refqtls(1),<span class="string">'Method'</span>,<span class="string">'approximate'</span>);
0233    ybar = quantile(logy,refqtls(2),<span class="string">'Method'</span>,<span class="string">'approximate'</span>);
0234 <span class="keyword">end</span>
0235 
0236 <span class="comment">% note: mean(x-y) = mean(x)-mean(y)</span>
0237 ab = [ exp(-(xbar-ybar)); order];
0238 
0239 <span class="comment">% transpose ci to be consistent with stats functions</span>
0240 ci = [nan nan; nan, nan];
0241 
0242 <span class="comment">% generic failure check</span>
0243 ok = all(isreal(ab));
0244 
0245 
0246 <a name="_sub5" href="#_subfunctions" class="code">function [ab,ci,ok] = fitQTL(logx,logy,weights,alpha,order,qtl,Nboot,inoctave)</a>
0247 
0248 <span class="comment">% quantile regression</span>
0249 <span class="keyword">if</span> inoctave
0250    error(<span class="string">'quantile regression not currently supported in octave, use nls'</span>)
0251 <span class="keyword">end</span>
0252 
0253 <span class="comment">% % If fitopts is abandoned, need to figure out how to deal with extra</span>
0254 <span class="comment">% parameters for quantile regression.</span>
0255 <span class="comment">% if isfield(fitopts,'qtl')</span>
0256 <span class="comment">%    qtl = fitopts.pctl;</span>
0257 <span class="comment">%    order = fitopts.order; % 1=linear regression</span>
0258 <span class="comment">%    Nboot = fitopts.Nboot;</span>
0259 <span class="comment">%    % alpha = fitopts.alpha;</span>
0260 <span class="comment">% elseif isnan(qtl)</span>
0261 <span class="comment">%    qtl = 0.05;</span>
0262 <span class="comment">% end</span>
0263 
0264 <span class="keyword">if</span> isnan(qtl)
0265    qtl = 0.05;
0266 <span class="keyword">end</span>
0267 
0268 <span class="comment">% apply the mask / weights</span>
0269 logx = logx(weights&gt;0);
0270 logy = logy(weights&gt;0);
0271 
0272 <span class="comment">% fit a,b using quantile regression</span>
0273 [ab,s] = bfra.deps.quantreg(logx,logy,qtl,order,Nboot,1-alpha);
0274 
0275 <span class="comment">% transform a to linear space and package a/b</span>
0276 ab = [exp(ab(1)); ab(2)];
0277 
0278 <span class="comment">% transpose ci to be consistent with stats functions</span>
0279 ci = transpose(s.ci_boot);   <span class="comment">% comes in the same order as confint</span>
0280 ci(1,:) = exp(ci(1,:));
0281 
0282 <span class="comment">% generic failure check</span>
0283 ok = all(isreal(ab));
0284 
0285 
0286 <span class="comment">% function [ab,ci,ok] = fitMLE(logx,logy,weights,alpha,sigx,sigy,rxy)</span>
0287 <span class="comment">%</span>
0288 <span class="comment">% % Set default values for maximum likelihood estimation</span>
0289 <span class="comment">% if nargin == 2</span>
0290 <span class="comment">%    sigx     =  std(logx);       % error in x</span>
0291 <span class="comment">%    sigy     =  std(logy);       % error in y</span>
0292 <span class="comment">%    rxy      =  0;               % correlation b/w error in x and y</span>
0293 <span class="comment">%    alpha    =  0.68;            % confidence level</span>
0294 <span class="comment">% end</span>
0295 <span class="comment">%</span>
0296 <span class="comment">% % fit</span>
0297 <span class="comment">% [ab,s] = yorkfit(logx,logy,sigx,sigy,rxy,1-alpha);</span>
0298 <span class="comment">%</span>
0299 <span class="comment">% ab = [exp(ab(1)); ab(2)];</span>
0300 <span class="comment">%</span>
0301 <span class="comment">% % transpose ci to be consistent with stats functions</span>
0302 <span class="comment">% ci = [exp(s.a_L), exp(s.a_H); s.b_L, s.b_H];</span>
0303 <span class="comment">%</span>
0304 <span class="comment">% % generic failure check</span>
0305 <span class="comment">% ok = true;</span>
0306 <span class="comment">% if any(~isreal(ab))</span>
0307 <span class="comment">%    ok = false;</span>
0308 <span class="comment">% end</span>
0309 
0310 
0311 <a name="_sub6" href="#_subfunctions" class="code">function [ab,ci,ok,fselect] = fitNLS(x,y,logx,logy,weights,alpha,inoctave)</a>
0312 
0313 <span class="keyword">if</span> inoctave
0314    [ab,ci,ok,fselect] = <a href="#_sub9" class="code" title="subfunction [ab,ci,ok,fselect] = fitNLS_octave(x,y,logx,logy,weights,alpha)">fitNLS_octave</a>(x,y,logx,logy,weights,alpha);
0315 <span class="keyword">else</span>
0316    <span class="keyword">try</span>
0317       [ab,ci,ok,fselect] = <a href="#_sub8" class="code" title="subfunction [ab,ci,ok,fselect] = fitNLS_matlab(x,y,logx,logy,weights,alpha)">fitNLS_matlab</a>(x,y,logx,logy,weights,alpha);
0318    <span class="keyword">catch</span>
0319       [ab,ci,ok,fselect] = <a href="#_sub9" class="code" title="subfunction [ab,ci,ok,fselect] = fitNLS_octave(x,y,logx,logy,weights,alpha)">fitNLS_octave</a>(x,y,logx,logy,weights,alpha);
0320    <span class="keyword">end</span>
0321 <span class="keyword">end</span>
0322 
0323 <a name="_sub7" href="#_subfunctions" class="code">function [Fit,ok] = evalFit(ab,x,y,ci,ok)</a>
0324 
0325 <span class="comment">% ok is from the fitting function, passed in here but not used</span>
0326 <span class="keyword">if</span> ok == false
0327    <span class="comment">% error?</span>
0328 <span class="keyword">end</span>
0329 
0330 Fit.ab = ab;
0331 
0332 <span class="comment">% all ci's should already be transformed to this form:</span>
0333 Fit.a = ab(1);
0334 Fit.b = ab(2);
0335 Fit.aL = ci(1,1);
0336 Fit.aH = ci(1,2);
0337 Fit.bL = ci(2,1);
0338 Fit.bH = ci(2,2);
0339 
0340 Fit.rsq = bfra.deps.rsquare(y,ab(1).*x.^ab(2));
0341 Fit.pvalue = nan;
0342 Fit.N = numel(y);
0343 Fit.x = x;
0344 Fit.y = y;
0345 
0346 <span class="comment">% generic failure check</span>
0347 ok = all(isreal(ab));
0348 
0349 <span class="comment">%    % any log-log regressions need the ci's transormed like this:</span>
0350 <span class="comment">%    aL      = exp(ci(1,1)); % 95% CI</span>
0351 <span class="comment">%    aH      = exp(ci(1,2));</span>
0352 <span class="comment">%    bL      = ci(2,1);      % = betaL</span>
0353 <span class="comment">%    bH      = ci(2,2);      % = betaH</span>
0354 
0355 <span class="comment">%    % any nlinfit regressions should already be in teh right order:</span>
0356 <span class="comment">%    aL      = ci(1,1); % for confint: ci(1,1);</span>
0357 <span class="comment">%    aH      = ci(1,2); % for confint: ci(2,1);</span>
0358 <span class="comment">%    bL      = ci(2,1); % for confint: ci(1,2);</span>
0359 <span class="comment">%    bH      = ci(2,2); % for confint: ci(2,2);</span>
0360 
0361 <span class="comment">% this does not work if robust fitting is used</span>
0362 <span class="comment">%r2      = 1-sum(R.^2)/sum((y-mean(y)).^2); % for fit: gof.rsquare;</span>
0363 <span class="comment">%figure; loglog(x,y,'o'); hold on; loglog(x,ab(1).*x.^ab(2))</span>
0364 
0365 
0366 <a name="_sub8" href="#_subfunctions" class="code">function [ab,ci,ok,fselect] = fitNLS_matlab(x,y,logx,logy,weights,alpha)</a>
0367 
0368 <span class="comment">% initial estimates using log-log linear fit</span>
0369 ok = true;
0370 ab0 = [ones(size(x)) logx]\logy;
0371 ab0 = [exp(ab0(1)), ab0(2)];
0372 
0373 <span class="comment">% to use user-specified weights:</span>
0374 <span class="comment">%opts = statset('Display','off','RobustWgtFun',[]);</span>
0375 <span class="comment">%ab = nlinfit(q,dqdt,fnc,ab0,opts,'Weights',weights);</span>
0376 
0377 <span class="comment">% initialize r2</span>
0378 rsq0 = bfra.deps.rsquare(y,ab0(1).*x.^ab0(2)); 
0379 rsq = rsq0;
0380 
0381 <span class="comment">% 'nlinfit' function options</span>
0382 fnc = @(ab,x)ab(1).*x.^ab(2);
0383 
0384 <span class="comment">% fnc = @(ab,x)ab(1).^(3-2.*ab(2)).*x.^ab(2);</span>
0385 
0386 <span class="comment">% opts1 = statset('Display','off','RobustWgtFun','bisquare');</span>
0387 opts1 = statset(<span class="string">'Display'</span>,<span class="string">'off'</span>,<span class="string">'RobustWgtFun'</span>,<span class="string">'bisquare'</span>);
0388 opts2 = statset(<span class="string">'Display'</span>,<span class="string">'off'</span>);
0389 
0390 <span class="comment">% 'fit' function options</span>
0391 ftype = fittype(@(a,b,x) (a.*x.^b));
0392 
0393 opts3 = fitoptions(<span class="string">'Method'</span>,<span class="string">'NonlinearLeastSquares'</span>,<span class="string">'Display'</span>,<span class="keyword">...</span>
0394    <span class="string">'off'</span>,<span class="string">'Robust'</span>,<span class="string">'Bisquare'</span>,<span class="string">'StartPoint'</span>,[ab0(1) ab0(2)]);
0395 
0396 opts4 = fitoptions(<span class="string">'Method'</span>,<span class="string">'NonlinearLeastSquares'</span>,          <span class="keyword">...</span>
0397    <span class="string">'Display'</span>,<span class="string">'off'</span>,<span class="string">'StartPoint'</span>,[ab0(1) ab0(2)]);
0398 
0399 <span class="comment">%  Summary of the method:</span>
0400 
0401 <span class="comment">%  start with linear=rsq0, set rsq=rsq0</span>
0402 <span class="comment">%  try nlinfit=rsq1, if rsq1&gt;rsq, set rsq=rsq1 and select nlinfit robust</span>
0403 <span class="comment">%  else, try fit=rsq3, if rsq3&gt;rsq, set rsq=rsq3 and select fit robust</span>
0404 <span class="comment">%  else, select 'none', rsq still equals rsq0</span>
0405 <span class="comment">%  if 'none', try non-robust nlinfit=rsq2, if rsq2&gt;rsq, set rsq=rsq2 and</span>
0406 <span class="comment">%  select nlinfit non-robust</span>
0407 <span class="comment">%  else</span>
0408 
0409 <span class="comment">% try robust nonlinear least squares fitting</span>
0410 ab1ok = true;
0411 <span class="keyword">try</span>
0412    [ab1,R1,~,C1] = nlinfit(x,y,fnc,ab0,opts1); <span class="comment">% R=resids,C=error variance</span>
0413    rsq1 = bfra.deps.rsquare(y,ab1(1).*x.^ab1(2));
0414 
0415 <span class="keyword">catch</span> ME
0416 
0417    <span class="keyword">if</span> (strcmp(ME.identifier,<span class="string">'stats:nlinfit:NoUsableObservations'</span>))
0418 
0419       msg = <span class="string">'Fitting failed using nlinfit at ab1'</span>;
0420       causeException = MException(<span class="string">'BFRA:fitab:fitting'</span>,msg);
0421       ME = addCause(ME,causeException);
0422 
0423    <span class="keyword">end</span>
0424    ab1ok = false;
0425    <span class="comment">% rethrow(ME)</span>
0426 <span class="keyword">end</span>
0427 
0428 <span class="comment">% if nlinfit worked and it's 'better' than rsq (here, rsq0), select it</span>
0429 <span class="keyword">if</span> ab1ok &amp;&amp; rsq1 &gt; rsq &amp;&amp; rsq1 &gt; 0
0430 
0431    fselect = <span class="string">'nlinfit_robust'</span>;
0432    rsq = rsq1;
0433 <span class="keyword">else</span>
0434 
0435    <span class="comment">% try curve fitting functions</span>
0436    ab3ok = true;
0437    <span class="keyword">try</span>
0438       f3 = fit(x,y,ftype,opts3);
0439       ab3 = coeffvalues(f3);
0440       rsq3 = bfra.deps.rsquare(y,ab3(1).*x.^ab3(2));
0441 
0442    <span class="keyword">catch</span> ME
0443 
0444       <span class="keyword">if</span> (strcmp(ME.identifier,<span class="string">'curvefit:fit:infComputed'</span>))
0445 
0446          msg = <span class="string">'Fitting failed using fit at ab3'</span>;
0447          causeException = MException(<span class="string">'BFRA:fitab:fitting'</span>,msg);
0448          ME = addCause(ME,causeException);
0449       <span class="keyword">end</span>
0450       ab3ok = false;
0451       <span class="comment">% rethrow(ME)</span>
0452    <span class="keyword">end</span>
0453 
0454    <span class="comment">% if fit worked, select it</span>
0455    <span class="keyword">if</span> ab3ok &amp;&amp; rsq3 &gt; rsq &amp;&amp; rsq3 &gt; 0
0456 
0457       fselect = <span class="string">'fit_robust'</span>;
0458       rsq = rsq3;
0459    <span class="keyword">else</span>
0460       fselect = <span class="string">'none'</span>;
0461 
0462    <span class="keyword">end</span>
0463 <span class="keyword">end</span>
0464 
0465 <span class="comment">% if neither nlinfit nor fit worked, try non-robust fitting</span>
0466 <span class="keyword">if</span> strcmp(fselect,<span class="string">'none'</span>)
0467 
0468    ab2ok = true;
0469    <span class="keyword">try</span>
0470       [ab2,R2,~,C2] = nlinfit(x,y,fnc,ab0,opts2);
0471       rsq2 = bfra.deps.rsquare(y,ab2(1).*x.^ab2(2));
0472 
0473    <span class="keyword">catch</span> ME
0474 
0475       <span class="keyword">if</span> (strcmp(ME.identifier,<span class="string">'stats:nlinfit:NoUsableObservations'</span>))
0476 
0477          msg = <span class="string">'Fitting failed using nlinfit at ab2'</span>;
0478          causeException = MException(<span class="string">'BFRA:fitab:fitting'</span>,msg);
0479          ME = addCause(ME,causeException);
0480       <span class="keyword">end</span>
0481       ab2ok = false;
0482       <span class="comment">%rethrow(ME)</span>
0483    <span class="keyword">end</span>
0484 
0485    <span class="keyword">if</span> ab2ok &amp;&amp; rsq2 &gt; rsq &amp;&amp; rsq2 &gt; 0
0486 
0487       fselect = <span class="string">'nlinfit'</span>;
0488       rsq = rsq2;
0489 
0490    <span class="keyword">else</span>                            <span class="comment">% try curve fitting functions</span>
0491 
0492       ab4ok = true;
0493       <span class="keyword">try</span>
0494          f4 = fit(x,y,ftype,opts4); ab4 = coeffvalues(f4);
0495          rsq4 = bfra.deps.rsquare(y,ab4(1).*x.^ab4(2));
0496 
0497       <span class="keyword">catch</span> ME
0498 
0499          <span class="keyword">if</span> (strcmp(ME.identifier,<span class="string">'curvefit:fit:infComputed'</span>))
0500 
0501             msg = <span class="string">'Fitting failed using fit at ab4'</span>;
0502             causeException = MException(<span class="string">'BFRA:fitab:fitting'</span>,msg);
0503             ME = addCause(ME,causeException);
0504          <span class="keyword">end</span>
0505          ab4ok = false;
0506          <span class="comment">%rethrow(ME)</span>
0507       <span class="keyword">end</span>
0508 
0509       <span class="comment">% we don't compare with rsq2 because we already know its &lt;rsq0</span>
0510       <span class="keyword">if</span> ab4ok &amp;&amp; rsq4 &gt; rsq &amp;&amp; rsq4 &gt; 0
0511 
0512          fselect = <span class="string">'fit'</span>;
0513          rsq = rsq4;
0514       <span class="keyword">else</span>
0515          fselect = <span class="string">'none'</span>;
0516       <span class="keyword">end</span>
0517    <span class="keyword">end</span>
0518 <span class="keyword">end</span>
0519 
0520 <span class="comment">% finally, if rsq is still low but linear rsq is good, choose lin</span>
0521 <span class="keyword">if</span> strcmp(fselect,<span class="string">'none'</span>) &amp;&amp; rsq &gt; 0
0522    fselect = <span class="string">'linear'</span>;
0523 <span class="keyword">elseif</span> rsq &lt; 0
0524    <span class="comment">% NOTE: nov 2022, i think in some cases we can get here and rsq &lt; 0 so I</span>
0525    <span class="comment">% added this option , previously there was no else, just end</span>
0526    fselect = <span class="string">'none'</span>;
0527 <span class="keyword">end</span>
0528 
0529 <span class="keyword">switch</span> fselect
0530 
0531    <span class="keyword">case</span> <span class="string">'none'</span>
0532       ok = false;   <span class="comment">% should never occur with option linear</span>
0533       ab = [nan,nan]; <span class="comment">% turns out can occur if q vs dqdt is decreasing</span>
0534       ci = [nan nan; nan nan];
0535       
0536    <span class="keyword">case</span> <span class="string">'nlinfit_robust'</span>
0537       ci = nlparci(ab1,R1,<span class="string">'covariance'</span>,C1,<span class="string">'alpha'</span>,alpha);
0538       ab = ab1;
0539 
0540    <span class="keyword">case</span> <span class="string">'nlinfit'</span>
0541       ci = nlparci(ab2,R2,<span class="string">'covariance'</span>,C2,<span class="string">'alpha'</span>,0.68);
0542       ab = ab2;
0543 
0544    <span class="keyword">case</span> <span class="string">'fit_robust'</span>
0545       ab = ab3;
0546       ci = transpose(confint(f3,alpha));
0547 
0548    <span class="keyword">case</span> <span class="string">'fit'</span>
0549       ab = ab4;
0550       ci = transpose(confint(f4,alpha));
0551 
0552    <span class="keyword">case</span> <span class="string">'linear'</span>
0553 
0554       [ab,ci] = regress(logy,[ones(size(y)) logx]);
0555       ci(1,:) = exp(ci(1,:));
0556       ab = [exp(ab(1)); ab(2)];
0557 
0558       <span class="comment">% might check metrics such as islineconvex(y), and if x&lt;xmin where</span>
0559       <span class="comment">% xmin is some very small flow value below which the data is corrupt</span>
0560 <span class="keyword">end</span>
0561 
0562 
0563 <a name="_sub9" href="#_subfunctions" class="code">function [ab,ci,ok,fselect] = fitNLS_octave(x,y,logx,logy,weights,alpha)</a>
0564 
0565 <span class="comment">% initial estimates using log-log linear fit</span>
0566 ok = true;
0567 ab0 = [ones(size(x)) logx]\logy;
0568 ab0 = [exp(ab0(1)), ab0(2)];
0569 
0570 <span class="comment">% initialize r2</span>
0571 rsq0 = bfra.deps.rsquare(y,ab0(1).*x.^ab0(2));
0572 rsq = rsq0;
0573 
0574 <span class="comment">% 'nlinfit' function options</span>
0575 fnc = @(ab,x)ab(1).*x.^ab(2);
0576 
0577 opts2 = statset(<span class="string">'Display'</span>,<span class="string">'off'</span>);
0578 
0579 <span class="comment">%  Summary of the method:</span>
0580 
0581 <span class="comment">%  start with linear=rsq0, set rsq=rsq0</span>
0582 <span class="comment">%  try non-robust nlinfit=rsq2, if rsq2&gt;rsq, set rsq=rsq2 and</span>
0583 <span class="comment">%  select nlinfit non-robust</span>
0584 <span class="comment">%  else</span>
0585 
0586 <span class="comment">% try non-robust nonlinear least squares fitting</span>
0587 ab2ok = true;
0588 <span class="keyword">try</span>
0589    [ab2,R2,~,C2] = nlinfit(x,y,fnc,ab0,opts2);
0590    rsq2 = bfra.deps.rsquare(y,ab2(1).*x.^ab2(2));
0591 
0592 <span class="keyword">catch</span> ME
0593 
0594    <span class="keyword">if</span> (strcmp(ME.identifier,<span class="string">'stats:nlinfit:NoUsableObservations'</span>))
0595 
0596       msg = <span class="string">'Fitting failed using nlinfit at ab2'</span>;
0597       causeException = MException(<span class="string">'BFRA:fitab:fitting'</span>,msg);
0598       ME = addCause(ME,causeException);
0599    <span class="keyword">end</span>
0600    ab2ok = false;
0601    <span class="comment">%rethrow(ME)</span>
0602 <span class="keyword">end</span>
0603 
0604 <span class="keyword">if</span> ab2ok &amp;&amp; rsq2 &gt; rsq &amp;&amp; rsq2 &gt; 0
0605 
0606    fselect = <span class="string">'nlinfit'</span>;
0607    rsq = rsq2;
0608 <span class="keyword">else</span>
0609    fselect = <span class="string">'none'</span>;
0610 <span class="keyword">end</span>
0611 
0612 <span class="comment">% finally, if rsq is still low but linear rsq is good, choose lin</span>
0613 <span class="keyword">if</span> strcmp(fselect,<span class="string">'none'</span>) &amp;&amp; rsq &gt; 0
0614    fselect = <span class="string">'linear'</span>;
0615 <span class="keyword">elseif</span> rsq &lt; 0
0616    fselect = <span class="string">'none'</span>;
0617 <span class="keyword">end</span>
0618 
0619 <span class="keyword">switch</span> fselect
0620 
0621    <span class="keyword">case</span> <span class="string">'none'</span>
0622       ok = false;
0623       ab = [nan,nan];
0624       ci = [nan nan; nan nan];
0625 
0626    <span class="keyword">case</span> <span class="string">'nlinfit'</span>
0627       ci = <a href="#_sub10" class="code" title="subfunction ci = nlparci_octave(beta, CovB, alpha)">nlparci_octave</a>(ab2, C2, 0.68);
0628       ab = ab2;
0629       
0630    <span class="keyword">case</span> <span class="string">'linear'</span>
0631 
0632       <span class="comment">%[B, BINT, R, RINT, STATS] = regress (Y, X, [ALPHA])</span>
0633       
0634       [ab,ci] = regress(logy,[ones(size(y)) logx]);
0635       ci(1,:) = exp(ci(1,:));
0636       ab = [exp(ab(1)); ab(2)];
0637 <span class="keyword">end</span>
0638 
0639 
0640 <a name="_sub10" href="#_subfunctions" class="code">function ci = nlparci_octave(beta, CovB, alpha)</a>
0641 
0642 <span class="comment">% INPUTS:</span>
0643 <span class="comment">%   beta: coefficients from nlinfit</span>
0644 <span class="comment">%   CovB: covariance matrix from nlinfit</span>
0645 <span class="comment">%   alpha: desired confidence level (e.g., 0.68 for 68%)</span>
0646 <span class="comment">%</span>
0647 <span class="comment">% OUTPUTS:</span>
0648 <span class="comment">%   ci_lower: lower bounds of the confidence intervals</span>
0649 <span class="comment">%   ci_upper: upper bounds of the confidence intervals</span>
0650 
0651 n = length(beta); <span class="comment">% Number of coefficients</span>
0652 dof = n - 1; <span class="comment">% Degrees of freedom</span>
0653 t_score = tinv(1 - (1 - alpha) / 2, dof); <span class="comment">% t-score for desired confidence level</span>
0654 se = sqrt(diag(CovB)); <span class="comment">% Standard errors of the coefficients</span>
0655 ci_lower = beta' - t_score * se; <span class="comment">% Lower bounds of the confidence intervals</span>
0656 ci_upper = beta' + t_score * se; <span class="comment">% Upper bounds of the confidence intervals</span>
0657 ci = [ci_lower, ci_upper];
0658 
0659 
0660 <span class="comment">%% INPUT PARSER</span>
0661 <a name="_sub11" href="#_subfunctions" class="code">function [weights, order, mask, qtl, refqtls, Nboot, alpha, plotfit] = </a><span class="keyword">...</span>
0662    parseinputs(q, dqdt, method, funcname, varargin)
0663 
0664 methodslist = {<span class="string">'nls'</span>,<span class="string">'ols'</span>,<span class="string">'mle'</span>,<span class="string">'qtl'</span>,<span class="string">'mean'</span>,<span class="string">'median'</span>,<span class="string">'envelope'</span>};
0665 validmethod = @(x) any(validatestring(x, methodslist));
0666 
0667 <span class="keyword">persistent</span> parser
0668 <span class="keyword">if</span> isempty(parser)
0669    parser = inputParser;
0670    parser.StructExpand = false;
0671    parser.addRequired( <span class="string">'q'</span>,                          @isnumeric   );
0672    parser.addRequired( <span class="string">'dqdt'</span>,                       @isnumeric   );
0673    parser.addRequired( <span class="string">'method'</span>,                     validmethod  );
0674    parser.addParameter(<span class="string">'weights'</span>,  1,                @isnumeric   );
0675    parser.addParameter(<span class="string">'order'</span>,    nan,              @isnumeric   );
0676    parser.addParameter(<span class="string">'mask'</span>,     1,                @islogical   );
0677    parser.addParameter(<span class="string">'quantile'</span>, 0.05,             @isnumeric   );
0678    parser.addParameter(<span class="string">'refqtls'</span>,  [0.50 0.50],      @isnumeric   );
0679    parser.addParameter(<span class="string">'Nboot'</span>,    100,              @isnumeric   );
0680    parser.addParameter(<span class="string">'alpha'</span>,    0.68,             @isnumeric   );
0681    parser.addParameter(<span class="string">'plotfit'</span>,  false,            @islogical   );
0682    parser.addParameter(<span class="string">'fitopts'</span>,  struct(),         @isstruct    );
0683 <span class="keyword">end</span>
0684 parser.FunctionName = funcname;
0685 parse(parser,q,dqdt,method,varargin{:});
0686 
0687 weights  = parser.Results.weights;
0688 order    = parser.Results.order;
0689 mask     = parser.Results.mask;
0690 qtl      = parser.Results.quantile;
0691 refqtls  = parser.Results.refqtls;
0692 Nboot    = parser.Results.Nboot;
0693 alpha    = parser.Results.alpha;
0694 plotfit  = parser.Results.plotfit;
0695 fitopts  = parser.Unmatched;
0696 
0697 <span class="keyword">if</span> isscalar(weights) &amp;&amp; weights == 1
0698    weights = ones(size(q));
0699 <span class="keyword">end</span>
0700 
0701 <span class="keyword">if</span> isscalar(mask) &amp;&amp; mask == 1
0702    mask = true(size(q));
0703 <span class="keyword">end</span>
0704 
0705 <span class="comment">% NOTE: fitopts is not implemented, but see bfra.Fit, where it could be used</span>
0706 <span class="comment">% to simplify calling this function from wrapper functions. Using the</span>
0707 <span class="comment">% unmatched method, it can be used to pass in arbitrary fitopts accepted</span>
0708 <span class="comment">% by any function but requires that the user know what to pass in.</span>
0709 
0710 <span class="comment">% could require:</span>
0711 <span class="comment">% if method = 'qtl', fitopts.quantile, fitopts.Nboot</span>
0712 <span class="comment">% if method = 'mle', fitopts.sigx, fitopts.sigy, fitopts.rxy</span>
0713 <span class="comment">% for all methods, fitopts.order, fitopts.alpha, fitopts.</span></pre></div>
</body>
</html>